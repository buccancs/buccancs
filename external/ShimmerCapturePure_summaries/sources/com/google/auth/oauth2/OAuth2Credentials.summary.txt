// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/com/google/auth/oauth2/OAuth2Credentials.java
// Size: 8048 bytes
// Modified: 2025-10-21 16:32:07.450106700 +0100

package com.google.auth.oauth2;

import com.google.api.client.util.Clock;
import com.google.auth.Credentials;
import com.google.auth.RequestMetadataCallback;
import com.google.common.base.MoreObjects;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ServiceLoader;
import java.util.concurrent.Executor;

/* loaded from: classes.dex */
public class OAuth2Credentials extends Credentials {
    private static final long MINIMUM_TOKEN_MILLISECONDS = 300000;
    private static final long serialVersionUID = 4556936364828217687L;
    private transient List<CredentialsChangedListener> changeListeners;
    transient Clock clock;
    private final Object lock;
    private Map<String, List<String>> requestMetadata;
    private AccessToken temporaryAccess;

    public interface CredentialsChangedListener {
        void onChanged(OAuth2Credentials oAuth2Credentials) throws IOException;
    }

    public final AccessToken getAccessToken() {
        return this.temporaryAccess;
    }

    @Override // com.google.auth.Credentials
    public String getAuthenticationType() {
        return "OAuth2";
    }

    protected Map<String, List<String>> getRequestMetadataInternal() {
        return this.requestMetadata;
    }

    @Override // com.google.auth.Credentials
    public boolean hasRequestMetadata() {
        return true;
    }

    @Override // com.google.auth.Credentials
    public boolean hasRequestMetadataOnly() {
        return true;
    }

    public static OAuth2Credentials create(AccessToken accessToken) {
        return newBuilder().setAccessToken(accessToken).build();
    }

    protected OAuth2Credentials() {
        this(null);
    }

    protected OAuth2Credentials(AccessToken accessToken) {
        this.lock = new byte[0];
        this.clock = Clock.SYSTEM;
        if (accessToken != null) {
            useAccessToken(accessToken);
        }
    }

    @Override // com.google.auth.Credentials
    public void getRequestMetadata(URI uri, Executor executor, RequestMetadataCallback requestMetadataCallback) {
        synchronized (this.lock) {
            if (shouldRefresh()) {
                super.getRequestMetadata(uri, executor, requestMetadataCallback);
            } else {
                requestMetadataCallback.onSuccess((Map) Preconditions.checkNotNull(this.requestMetadata, "cached requestMetadata"));
            }
        }
    }

    @Override // com.google.auth.Credentials
    public Map<String, List<String>> getRequestMetadata(URI uri) throws IOException {
        Map<String, List<String>> map;
        synchronized (this.lock) {
            if (shouldRefresh()) {
                refresh();
            }
            map = (Map) Preconditions.checkNotNull(this.requestMetadata, "requestMetadata");
        }
        return map;
    }

    @Override // com.google.auth.Credentials
    public void refresh() throws IOException {
        synchronized (this.lock) {
            this.requestMetadata = null;
            this.temporaryAccess = null;
            useAccessToken((AccessToken) Preconditions.checkNotNull(refreshAccessToken(), "new access token"));
            List<CredentialsChangedListener> list = this.changeListeners;
            if (list != null) {
                Iterator<CredentialsChangedListener> it2 = list.iterator();
                while (it2.hasNext()) {
                    it2.next().onChanged(this);
                }
            }
        }
    }

    public void refreshIfExpired() throws IOException {
        synchronized (this.lock) {
            if (shouldRefresh()) {
                refresh();
            }
        }
    }

    private void useAccessToken(AccessToken accessToken) {
        this.temporaryAccess = accessToken;
        this.requestMetadata = Collections.singletonMap("Authorization", Collections.singletonList("Bearer " + accessToken.getTokenValue()));
    }

    private boolean shouldRefresh() {
        Long expiresInMilliseconds = getExpiresInMilliseconds();
        return this.requestMetadata == null || (expiresInMilliseconds != null && expiresInMilliseconds.longValue() <= MINIMUM_TOKEN_MILLISECONDS);
    }

    public AccessToken refreshAccessToken() throws IOException {
        throw new IllegalStateException("OAuth2Credentials instance does not support refreshing the access token. An instance with a new access token should be used, or a derived type that supports refreshing.");
    }

    public final void addChangeListener(CredentialsChangedListener credentialsChangedListener) {
        synchronized (this.lock) {
            if (this.changeListeners == null) {
                this.changeListeners = new ArrayList();
            }
            this.changeListeners.add(credentialsChangedListener);
        }
    }

    public final void removeChangeListener(CredentialsChangedListener credentialsChangedListener) {
        synchronized (this.lock) {
            List<CredentialsChangedListener> list = this.changeListeners;
            if (list != null) {
                list.remove(credentialsChangedListener);
            }
        }
    }

    private Long getExpiresInMilliseconds() {
        Date expirationTime;
        AccessToken accessToken = this.temporaryAccess;
        if (accessToken == null || (expirationTime = accessToken.getExpirationTime()) == null) {
            return null;
        }
        return Long.valueOf(expirationTime.getTime() - this.clock.currentTimeMillis());
    }

    public int hashCode() {
        return Objects.hash(this.requestMetadata, this.temporaryAccess);
    }

    public String toString() {
        return MoreObjects.toStringHelper(this).add("requestMetadata", this.requestMetadata).add("temporaryAccess", this.temporaryAccess).toString();
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof OAuth2Credentials)) {
            return false;
        }
        OAuth2Credentials oAuth2Credentials = (OAuth2Credentials) obj;
        return Objects.equals(this.requestMetadata, oAuth2Credentials.requestMetadata) && Objects.equals(this.temporaryAccess, oAuth2Credentials.temporaryAccess);
    }

    private void readObject(ObjectInputStream objectInputStream) throws ClassNotFoundException, IOException {
        objectInputStream.defaultReadObject();
        this.clock = Clock.SYSTEM;
    }

    protected static <T> T newInstance(String str) throws IOException, ClassNotFoundException {
        try {
            return (T) Class.forName(str).newInstance();
        } catch (IllegalAccessException | InstantiationException e) {
            throw new IOException(e);
        }
    }

    protected static <T> T getFromServiceLoader(Class<? extends T> cls, T t) {
        return (T) Iterables.getFirst(ServiceLoader.load(cls), t);
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public Builder toBuilder() {
        return new Builder(this);
    }

    public static class Builder {
        private AccessToken accessToken;

        public AccessToken getAccessToken() {
            return this.accessToken;
        }

        public Builder setAccessToken(AccessToken accessToken) {
            this.accessToken = accessToken;
            return this;
        }

        protected Builder() {
        }

        protected Builder(OAuth2Credentials oAuth2Credentials) {
            this.accessToken = oAuth2Credentials.getAccessToken();
        }

        public OAuth2Credentials build() {
            return new OAuth2Credentials(this.accessToken);
        }
    }
}
