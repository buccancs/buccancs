// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/collections/iterators/IteratorChain.java
// Size: 3664 bytes
// Modified: 2025-10-21 16:32:04.978857000 +0100

package org.apache.commons.collections.iterators;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.apache.commons.collections.list.UnmodifiableList;

/* loaded from: classes5.dex */
public class IteratorChain implements Iterator {
    protected final List iteratorChain = new ArrayList();
    protected int currentIteratorIndex = 0;
    protected Iterator currentIterator = null;
    protected Iterator lastUsedIterator = null;
    protected boolean isLocked = false;

    private void lockChain() {
        if (this.isLocked) {
            return;
        }
        this.isLocked = true;
    }

    public boolean isLocked() {
        return this.isLocked;
    }

    public IteratorChain() {
    }

    public IteratorChain(Iterator it2) {
        addIterator(it2);
    }

    public IteratorChain(Iterator it2, Iterator it3) {
        addIterator(it2);
        addIterator(it3);
    }

    public IteratorChain(Iterator[] itArr) {
        for (Iterator it2 : itArr) {
            addIterator(it2);
        }
    }

    public IteratorChain(Collection collection) {
        Iterator it2 = collection.iterator();
        while (it2.hasNext()) {
            addIterator((Iterator) it2.next());
        }
    }

    public void addIterator(Iterator it2) {
        checkLocked();
        if (it2 == null) {
            throw new NullPointerException("Iterator must not be null");
        }
        this.iteratorChain.add(it2);
    }

    public void setIterator(int i, Iterator it2) throws IndexOutOfBoundsException {
        checkLocked();
        if (it2 == null) {
            throw new NullPointerException("Iterator must not be null");
        }
        this.iteratorChain.set(i, it2);
    }

    public List getIterators() {
        return UnmodifiableList.decorate(this.iteratorChain);
    }

    public int size() {
        return this.iteratorChain.size();
    }

    private void checkLocked() {
        if (this.isLocked) {
            throw new UnsupportedOperationException("IteratorChain cannot be changed after the first use of a method from the Iterator interface");
        }
    }

    protected void updateCurrentIterator() {
        if (this.currentIterator == null) {
            if (this.iteratorChain.isEmpty()) {
                this.currentIterator = EmptyIterator.INSTANCE;
            } else {
                this.currentIterator = (Iterator) this.iteratorChain.get(0);
            }
            this.lastUsedIterator = this.currentIterator;
        }
        while (!this.currentIterator.hasNext() && this.currentIteratorIndex < this.iteratorChain.size() - 1) {
            int i = this.currentIteratorIndex + 1;
            this.currentIteratorIndex = i;
            this.currentIterator = (Iterator) this.iteratorChain.get(i);
        }
    }

    @Override // java.util.Iterator
    public boolean hasNext() {
        lockChain();
        updateCurrentIterator();
        Iterator it2 = this.currentIterator;
        this.lastUsedIterator = it2;
        return it2.hasNext();
    }

    @Override // java.util.Iterator
    public Object next() {
        lockChain();
        updateCurrentIterator();
        Iterator it2 = this.currentIterator;
        this.lastUsedIterator = it2;
        return it2.next();
    }

    @Override // java.util.Iterator
    public void remove() {
        lockChain();
        if (this.currentIterator == null) {
            updateCurrentIterator();
        }
        this.lastUsedIterator.remove();
    }
}
