// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
// Size: 5005 bytes
// Modified: 2025-10-21 16:32:06.599699200 +0100

package org.apache.commons.math.optimization.univariate;

import org.apache.commons.math.FunctionEvaluationException;
import org.apache.commons.math.MaxIterationsExceededException;
import org.apache.commons.math.exception.NotStrictlyPositiveException;
import org.apache.commons.math.optimization.GoalType;
import org.apache.commons.math.util.FastMath;

/* JADX WARN: Classes with same name are omitted:
  classes5.dex
 */
/* loaded from: ShimmerCapture_1.3.1_APKPure.apk:libs/commons-math-2.2.jar:org/apache/commons/math/optimization/univariate/BrentOptimizer.class */
public class BrentOptimizer extends AbstractUnivariateRealOptimizer {
    private static final double GOLDEN_SECTION = 0.5d * (3.0d - FastMath.sqrt(5.0d));

    public BrentOptimizer() {
        setMaxEvaluations(1000);
        setMaximalIterationCount(100);
        setAbsoluteAccuracy(1.0E-11d);
        setRelativeAccuracy(1.0E-9d);
    }

    @Override // org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer
    protected double doOptimize() throws FunctionEvaluationException, MaxIterationsExceededException {
        return localMin(getGoalType() == GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());
    }

    private double localMin(boolean isMinim, double lo, double mid, double hi, double eps, double t) throws FunctionEvaluationException, MaxIterationsExceededException {
        double a;
        double b;
        double u;
        if (eps <= 0.0d) {
            throw new NotStrictlyPositiveException(Double.valueOf(eps));
        }
        if (t <= 0.0d) {
            throw new NotStrictlyPositiveException(Double.valueOf(t));
        }
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }
        double x = mid;
        double v = x;
        double w = x;
        double d = 0.0d;
        double e = 0.0d;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;
        while (true) {
            double m = 0.5d * (a + b);
            double tol1 = (eps * FastMath.abs(x)) + t;
            double tol2 = 2.0d * tol1;
            if (FastMath.abs(x - m) <= tol2 - (0.5d * (b - a))) {
                break;
            }
            if (FastMath.abs(e) > tol1) {
                double r = (x - w) * (fx - fv);
                double q = (x - v) * (fx - fw);
                double p = ((x - v) * q) - ((x - w) * r);
                double q2 = 2.0d * (q - r);
                if (q2 > 0.0d) {
                    p = -p;
                } else {
                    q2 = -q2;
                }
                double r2 = e;
                e = d;
                if (p > q2 * (a - x) && p < q2 * (b - x) && FastMath.abs(p) < FastMath.abs(0.5d * q2 * r2)) {
                    d = p / q2;
                    double u2 = x + d;
                    if (u2 - a < tol2 || b - u2 < tol2) {
                        if (x <= m) {
                            d = tol1;
                        } else {
                            d = -tol1;
                        }
                    }
                } else {
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }
            } else {
                if (x < m) {
                    e = b - x;
                } else {
                    e = a - x;
                }
                d = GOLDEN_SECTION * e;
            }
            if (FastMath.abs(d) >= tol1) {
                u = x + d;
            } else if (d >= 0.0d) {
                u = x + tol1;
            } else {
                u = x - tol1;
            }
            double fu = computeObjectiveValue(u);
            if (!isMinim) {
                fu = -fu;
            }
            if (fu <= fx) {
                if (u < x) {
                    b = x;
                } else {
                    a = x;
                }
                v = w;
                fv = fw;
                w = x;
                fw = fx;
                x = u;
                fx = fu;
            } else {
                if (u < x) {
                    a = u;
                } else {
                    b = u;
                }
                if (fu <= fw || w == x) {
                    v = w;
                    fv = fw;
                    w = u;
                    fw = fu;
                } else if (fu <= fv || v == x || v == w) {
                    v = u;
                    fv = fu;
                }
            }
            incrementIterationsCounter();
        }
        setFunctionValue(isMinim ? fx : -fx);
        return x;
    }
}
