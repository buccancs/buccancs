// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
// Size: 14320 bytes
// Modified: 2025-10-21 16:32:08.370201200 +0100

package org.apache.commons.math.optimization.general;

import java.util.Arrays;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.optimization.OptimizationException;
import org.apache.commons.math.util.FastMath;

/* JADX WARN: Classes with same name are omitted:
  classes5.dex
 */
/* loaded from: ShimmerCapture_1.3.1_APKPure.apk:libs/commons-math-2.2.jar:org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.class */
public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {
    private int solvedCols;
    private double[] diagR;
    private double[] jacNorm;
    private double[] beta;
    private int[] permutation;
    private int rank;
    private double lmPar;
    private double[] lmDir;
    private double initialStepBoundFactor;
    private double costRelativeTolerance;
    private double parRelativeTolerance;
    private double orthoTolerance;
    private double qrRankingThreshold;

    public LevenbergMarquardtOptimizer() {
        setMaxIterations(1000);
        setConvergenceChecker(null);
        setInitialStepBoundFactor(100.0d);
        setCostRelativeTolerance(1.0E-10d);
        setParRelativeTolerance(1.0E-10d);
        setOrthoTolerance(1.0E-10d);
        setQRRankingThreshold(Double.MIN_NORMAL);
    }

    public void setInitialStepBoundFactor(double initialStepBoundFactor) {
        this.initialStepBoundFactor = initialStepBoundFactor;
    }

    public void setCostRelativeTolerance(double costRelativeTolerance) {
        this.costRelativeTolerance = costRelativeTolerance;
    }

    public void setParRelativeTolerance(double parRelativeTolerance) {
        this.parRelativeTolerance = parRelativeTolerance;
    }

    public void setOrthoTolerance(double orthoTolerance) {
        this.orthoTolerance = orthoTolerance;
    }

    public void setQRRankingThreshold(double threshold) {
        this.qrRankingThreshold = threshold;
    }

    /* JADX WARN: Code restructure failed: missing block: B:124:0x0542, code lost:
    
        return r23;
     */
    @Override // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    protected org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException, java.lang.IllegalArgumentException {
        /*
            Method dump skipped, instructions count: 1477
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize():org.apache.commons.math.optimization.VectorialPointValuePair");
    }

    private void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3) {
        for (int j = 0; j < this.rank; j++) {
            this.lmDir[this.permutation[j]] = qy[j];
        }
        for (int j2 = this.rank; j2 < this.cols; j2++) {
            this.lmDir[this.permutation[j2]] = 0.0d;
        }
        for (int k = this.rank - 1; k >= 0; k--) {
            int pk = this.permutation[k];
            double ypk = this.lmDir[pk] / this.diagR[pk];
            for (int i = 0; i < k; i++) {
                double[] dArr = this.lmDir;
                int i2 = this.permutation[i];
                dArr[i2] = dArr[i2] - (ypk * this.wjacobian[i][pk]);
            }
            this.lmDir[pk] = ypk;
        }
        double dxNorm = 0.0d;
        for (int j3 = 0; j3 < this.solvedCols; j3++) {
            int pj = this.permutation[j3];
            double s = diag[pj] * this.lmDir[pj];
            work1[pj] = s;
            dxNorm += s * s;
        }
        double dxNorm2 = FastMath.sqrt(dxNorm);
        double fp = dxNorm2 - delta;
        if (fp <= 0.1d * delta) {
            this.lmPar = 0.0d;
            return;
        }
        double parl = 0.0d;
        if (this.rank == this.solvedCols) {
            for (int j4 = 0; j4 < this.solvedCols; j4++) {
                int pj2 = this.permutation[j4];
                work1[pj2] = work1[pj2] * (diag[pj2] / dxNorm2);
            }
            double sum2 = 0.0d;
            for (int j5 = 0; j5 < this.solvedCols; j5++) {
                int pj3 = this.permutation[j5];
                double sum = 0.0d;
                for (int i3 = 0; i3 < j5; i3++) {
                    sum += this.wjacobian[i3][pj3] * work1[this.permutation[i3]];
                }
                double s2 = (work1[pj3] - sum) / this.diagR[pj3];
                work1[pj3] = s2;
                sum2 += s2 * s2;
            }
            parl = fp / (delta * sum2);
        }
        double sum22 = 0.0d;
        for (int j6 = 0; j6 < this.solvedCols; j6++) {
            int pj4 = this.permutation[j6];
            double sum3 = 0.0d;
            for (int i4 = 0; i4 <= j6; i4++) {
                sum3 += this.wjacobian[i4][pj4] * qy[i4];
            }
            double sum4 = sum3 / diag[pj4];
            sum22 += sum4 * sum4;
        }
        double gNorm = FastMath.sqrt(sum22);
        double paru = gNorm / delta;
        if (paru == 0.0d) {
            paru = 2.2251E-308d / FastMath.min(delta, 0.1d);
        }
        this.lmPar = FastMath.min(paru, FastMath.max(this.lmPar, parl));
        if (this.lmPar == 0.0d) {
            this.lmPar = gNorm / dxNorm2;
        }
        for (int countdown = 10; countdown >= 0; countdown--) {
            if (this.lmPar == 0.0d) {
                this.lmPar = FastMath.max(2.2251E-308d, 0.001d * paru);
            }
            double sPar = FastMath.sqrt(this.lmPar);
            for (int j7 = 0; j7 < this.solvedCols; j7++) {
                int pj5 = this.permutation[j7];
                work1[pj5] = sPar * diag[pj5];
            }
            determineLMDirection(qy, work1, work2, work3);
            double dxNorm3 = 0.0d;
            for (int j8 = 0; j8 < this.solvedCols; j8++) {
                int pj6 = this.permutation[j8];
                double s3 = diag[pj6] * this.lmDir[pj6];
                work3[pj6] = s3;
                dxNorm3 += s3 * s3;
            }
            double dxNorm4 = FastMath.sqrt(dxNorm3);
            double previousFP = fp;
            fp = dxNorm4 - delta;
            if (FastMath.abs(fp) <= 0.1d * delta) {
                return;
            }
            if (parl == 0.0d && fp <= previousFP && previousFP < 0.0d) {
                return;
            }
            for (int j9 = 0; j9 < this.solvedCols; j9++) {
                int pj7 = this.permutation[j9];
                work1[pj7] = (work3[pj7] * diag[pj7]) / dxNorm4;
            }
            for (int j10 = 0; j10 < this.solvedCols; j10++) {
                int pj8 = this.permutation[j10];
                work1[pj8] = work1[pj8] / work2[j10];
                double tmp = work1[pj8];
                for (int i5 = j10 + 1; i5 < this.solvedCols; i5++) {
                    int i6 = this.permutation[i5];
                    work1[i6] = work1[i6] - (this.wjacobian[i5][pj8] * tmp);
                }
            }
            double sum23 = 0.0d;
            for (int j11 = 0; j11 < this.solvedCols; j11++) {
                double s4 = work1[this.permutation[j11]];
                sum23 += s4 * s4;
            }
            double correction = fp / (delta * sum23);
            if (fp > 0.0d) {
                parl = FastMath.max(parl, this.lmPar);
            } else if (fp < 0.0d) {
                paru = FastMath.min(paru, this.lmPar);
            }
            this.lmPar = FastMath.max(parl, this.lmPar + correction);
        }
    }

    private void determineLMDirection(double[] qy, double[] diag, double[] lmDiag, double[] work) {
        double cos;
        double sin;
        for (int j = 0; j < this.solvedCols; j++) {
            int pj = this.permutation[j];
            for (int i = j + 1; i < this.solvedCols; i++) {
                this.wjacobian[i][pj] = this.wjacobian[j][this.permutation[i]];
            }
            this.lmDir[j] = this.diagR[pj];
            work[j] = qy[j];
        }
        for (int j2 = 0; j2 < this.solvedCols; j2++) {
            int pj2 = this.permutation[j2];
            double dpj = diag[pj2];
            if (dpj != 0.0d) {
                Arrays.fill(lmDiag, j2 + 1, lmDiag.length, 0.0d);
            }
            lmDiag[j2] = dpj;
            double qtbpj = 0.0d;
            for (int k = j2; k < this.solvedCols; k++) {
                int pk = this.permutation[k];
                if (lmDiag[k] != 0.0d) {
                    double rkk = this.wjacobian[k][pk];
                    if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {
                        double cotan = rkk / lmDiag[k];
                        sin = 1.0d / FastMath.sqrt(1.0d + (cotan * cotan));
                        cos = sin * cotan;
                    } else {
                        double tan = lmDiag[k] / rkk;
                        cos = 1.0d / FastMath.sqrt(1.0d + (tan * tan));
                        sin = cos * tan;
                    }
                    this.wjacobian[k][pk] = (cos * rkk) + (sin * lmDiag[k]);
                    double temp = (cos * work[k]) + (sin * qtbpj);
                    qtbpj = ((-sin) * work[k]) + (cos * qtbpj);
                    work[k] = temp;
                    for (int i2 = k + 1; i2 < this.solvedCols; i2++) {
                        double rik = this.wjacobian[i2][pk];
                        double temp2 = (cos * rik) + (sin * lmDiag[i2]);
                        lmDiag[i2] = ((-sin) * rik) + (cos * lmDiag[i2]);
                        this.wjacobian[i2][pk] = temp2;
                    }
                }
            }
            lmDiag[j2] = this.wjacobian[j2][this.permutation[j2]];
            this.wjacobian[j2][this.permutation[j2]] = this.lmDir[j2];
        }
        int nSing = this.solvedCols;
        for (int j3 = 0; j3 < this.solvedCols; j3++) {
            if (lmDiag[j3] == 0.0d && nSing == this.solvedCols) {
                nSing = j3;
            }
            if (nSing < this.solvedCols) {
                work[j3] = 0.0d;
            }
        }
        if (nSing > 0) {
            for (int j4 = nSing - 1; j4 >= 0; j4--) {
                int pj3 = this.permutation[j4];
                double sum = 0.0d;
                for (int i3 = j4 + 1; i3 < nSing; i3++) {
                    sum += this.wjacobian[i3][pj3] * work[i3];
                }
                work[j4] = (work[j4] - sum) / lmDiag[j4];
            }
        }
        for (int j5 = 0; j5 < this.lmDir.length; j5++) {
            this.lmDir[this.permutation[j5]] = work[j5];
        }
    }

    private void qrDecomposition() throws OptimizationException {
        for (int k = 0; k < this.cols; k++) {
            this.permutation[k] = k;
            double norm2 = 0.0d;
            for (int i = 0; i < this.wjacobian.length; i++) {
                double akk = this.wjacobian[i][k];
                norm2 += akk * akk;
            }
            this.jacNorm[k] = FastMath.sqrt(norm2);
        }
        for (int k2 = 0; k2 < this.cols; k2++) {
            int nextColumn = -1;
            double ak2 = Double.NEGATIVE_INFINITY;
            for (int i2 = k2; i2 < this.cols; i2++) {
                double norm22 = 0.0d;
                for (int j = k2; j < this.wjacobian.length; j++) {
                    double aki = this.wjacobian[j][this.permutation[i2]];
                    norm22 += aki * aki;
                }
                if (!Double.isInfinite(norm22) && !Double.isNaN(norm22)) {
                    if (norm22 > ak2) {
                        nextColumn = i2;
                        ak2 = norm22;
                    }
                } else {
                    throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, Integer.valueOf(this.rows), Integer.valueOf(this.cols));
                }
            }
            if (ak2 <= this.qrRankingThreshold) {
                this.rank = k2;
                return;
            }
            int pk = this.permutation[nextColumn];
            this.permutation[nextColumn] = this.permutation[k2];
            this.permutation[k2] = pk;
            double akk2 = this.wjacobian[k2][pk];
            double alpha = akk2 > 0.0d ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);
            double betak = 1.0d / (ak2 - (akk2 * alpha));
            this.beta[pk] = betak;
            this.diagR[pk] = alpha;
            double[] dArr = this.wjacobian[k2];
            dArr[pk] = dArr[pk] - alpha;
            for (int dk = (this.cols - 1) - k2; dk > 0; dk--) {
                double gamma = 0.0d;
                for (int j2 = k2; j2 < this.wjacobian.length; j2++) {
                    gamma += this.wjacobian[j2][pk] * this.wjacobian[j2][this.permutation[k2 + dk]];
                }
                double gamma2 = gamma * betak;
                for (int j3 = k2; j3 < this.wjacobian.length; j3++) {
                    double[] dArr2 = this.wjacobian[j3];
                    int i3 = this.permutation[k2 + dk];
                    dArr2[i3] = dArr2[i3] - (gamma2 * this.wjacobian[j3][pk]);
                }
            }
        }
        this.rank = this.solvedCols;
    }

    private void qTy(double[] y) {
        for (int k = 0; k < this.cols; k++) {
            int pk = this.permutation[k];
            double gamma = 0.0d;
            for (int i = k; i < this.rows; i++) {
                gamma += this.wjacobian[i][pk] * y[i];
            }
            double gamma2 = gamma * this.beta[pk];
            for (int i2 = k; i2 < this.rows; i2++) {
                int i3 = i2;
                y[i3] = y[i3] - (gamma2 * this.wjacobian[i2][pk]);
            }
        }
    }
}
