// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java
// Size: 7630 bytes
// Modified: 2025-10-21 16:32:08.350727200 +0100

package org.apache.commons.math.distribution;

import java.io.Serializable;
import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.util.FastMath;
import org.apache.commons.math.util.MathUtils;

/* JADX WARN: Classes with same name are omitted:
  classes5.dex
 */
/* loaded from: ShimmerCapture_1.3.1_APKPure.apk:libs/commons-math-2.2.jar:org/apache/commons/math/distribution/HypergeometricDistributionImpl.class */
public class HypergeometricDistributionImpl extends AbstractIntegerDistribution implements HypergeometricDistribution, Serializable {
    private static final long serialVersionUID = -436928820673516179L;
    private int numberOfSuccesses;
    private int populationSize;
    private int sampleSize;

    public HypergeometricDistributionImpl(int populationSize, int numberOfSuccesses, int sampleSize) {
        if (numberOfSuccesses > populationSize) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE, Integer.valueOf(numberOfSuccesses), Integer.valueOf(populationSize));
        }
        if (sampleSize > populationSize) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE, Integer.valueOf(sampleSize), Integer.valueOf(populationSize));
        }
        setPopulationSizeInternal(populationSize);
        setSampleSizeInternal(sampleSize);
        setNumberOfSuccessesInternal(numberOfSuccesses);
    }

    @Override // org.apache.commons.math.distribution.AbstractIntegerDistribution, org.apache.commons.math.distribution.IntegerDistribution
    public double cumulativeProbability(int x) {
        double ret;
        int[] domain = getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);
        if (x < domain[0]) {
            ret = 0.0d;
        } else if (x >= domain[1]) {
            ret = 1.0d;
        } else {
            ret = innerCumulativeProbability(domain[0], x, 1, this.populationSize, this.numberOfSuccesses, this.sampleSize);
        }
        return ret;
    }

    private int[] getDomain(int n, int m, int k) {
        return new int[]{getLowerDomain(n, m, k), getUpperDomain(m, k)};
    }

    @Override // org.apache.commons.math.distribution.AbstractIntegerDistribution
    protected int getDomainLowerBound(double p) {
        return getLowerDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);
    }

    @Override // org.apache.commons.math.distribution.AbstractIntegerDistribution
    protected int getDomainUpperBound(double p) {
        return getUpperDomain(this.sampleSize, this.numberOfSuccesses);
    }

    private int getLowerDomain(int n, int m, int k) {
        return FastMath.max(0, m - (n - k));
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    public int getNumberOfSuccesses() {
        return this.numberOfSuccesses;
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    public int getPopulationSize() {
        return this.populationSize;
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    public int getSampleSize() {
        return this.sampleSize;
    }

    private int getUpperDomain(int m, int k) {
        return FastMath.min(k, m);
    }

    @Override // org.apache.commons.math.distribution.IntegerDistribution
    public double probability(int x) {
        double ret;
        int[] domain = getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);
        if (x < domain[0] || x > domain[1]) {
            ret = 0.0d;
        } else {
            double p = this.sampleSize / this.populationSize;
            double q = (this.populationSize - this.sampleSize) / this.populationSize;
            double p1 = SaddlePointExpansion.logBinomialProbability(x, this.numberOfSuccesses, p, q);
            double p2 = SaddlePointExpansion.logBinomialProbability(this.sampleSize - x, this.populationSize - this.numberOfSuccesses, p, q);
            double p3 = SaddlePointExpansion.logBinomialProbability(this.sampleSize, this.populationSize, p, q);
            ret = FastMath.exp((p1 + p2) - p3);
        }
        return ret;
    }

    private double probability(int n, int m, int k, int x) {
        return FastMath.exp((MathUtils.binomialCoefficientLog(m, x) + MathUtils.binomialCoefficientLog(n - m, k - x)) - MathUtils.binomialCoefficientLog(n, k));
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    @Deprecated
    public void setNumberOfSuccesses(int num) {
        setNumberOfSuccessesInternal(num);
    }

    private void setNumberOfSuccessesInternal(int num) {
        if (num < 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES, Integer.valueOf(num));
        }
        this.numberOfSuccesses = num;
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    @Deprecated
    public void setPopulationSize(int size) {
        setPopulationSizeInternal(size);
    }

    private void setPopulationSizeInternal(int size) {
        if (size <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE, Integer.valueOf(size));
        }
        this.populationSize = size;
    }

    @Override // org.apache.commons.math.distribution.HypergeometricDistribution
    @Deprecated
    public void setSampleSize(int size) {
        setSampleSizeInternal(size);
    }

    private void setSampleSizeInternal(int size) {
        if (size < 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, Integer.valueOf(size));
        }
        this.sampleSize = size;
    }

    public double upperCumulativeProbability(int x) {
        double ret;
        int[] domain = getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);
        if (x < domain[0]) {
            ret = 1.0d;
        } else if (x > domain[1]) {
            ret = 0.0d;
        } else {
            ret = innerCumulativeProbability(domain[1], x, -1, this.populationSize, this.numberOfSuccesses, this.sampleSize);
        }
        return ret;
    }

    private double innerCumulativeProbability(int x0, int x1, int dx, int n, int m, int k) {
        double dProbability = probability(n, m, k, x0);
        while (true) {
            double ret = dProbability;
            if (x0 != x1) {
                x0 += dx;
                dProbability = ret + probability(n, m, k, x0);
            } else {
                return ret;
            }
        }
    }

    public int getSupportLowerBound() {
        return FastMath.max(0, (getSampleSize() + getNumberOfSuccesses()) - getPopulationSize());
    }

    public int getSupportUpperBound() {
        return FastMath.min(getNumberOfSuccesses(), getSampleSize());
    }

    protected double getNumericalMean() {
        return (getSampleSize() * getNumberOfSuccesses()) / getPopulationSize();
    }

    public double getNumericalVariance() {
        double N = getPopulationSize();
        double m = getNumberOfSuccesses();
        double n = getSampleSize();
        return (((n * m) * (N - n)) * (N - m)) / ((N * N) * (N - 1.0d));
    }
}
