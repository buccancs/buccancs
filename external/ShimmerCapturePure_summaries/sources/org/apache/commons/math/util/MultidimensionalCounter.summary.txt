// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math/util/MultidimensionalCounter.java
// Size: 6014 bytes
// Modified: 2025-10-21 16:32:05.134759300 +0100

package org.apache.commons.math.util;

import org.apache.commons.math.exception.DimensionMismatchException;
import org.apache.commons.math.exception.NotStrictlyPositiveException;
import org.apache.commons.math.exception.OutOfRangeException;

/* JADX WARN: Classes with same name are omitted:
  classes5.dex
 */
/* loaded from: ShimmerCapture_1.3.1_APKPure.apk:libs/commons-math-2.2.jar:org/apache/commons/math/util/MultidimensionalCounter.class */
public class MultidimensionalCounter implements Iterable<Integer> {
    private final int dimension;
    private final int[] uniCounterOffset;
    private final int[] size;
    private final int totalSize;
    private final int last;

    /* JADX WARN: Classes with same name are omitted:
  classes5.dex
 */
    /* loaded from: ShimmerCapture_1.3.1_APKPure.apk:libs/commons-math-2.2.jar:org/apache/commons/math/util/MultidimensionalCounter$Iterator.class */
    public class Iterator implements java.util.Iterator<Integer> {
        private final int[] counter;
        private int count = -1;

        Iterator() {
            this.counter = new int[MultidimensionalCounter.this.dimension];
            this.counter[MultidimensionalCounter.this.last] = -1;
        }

        @Override // java.util.Iterator
        public boolean hasNext() {
            for (int i = 0; i < MultidimensionalCounter.this.dimension; i++) {
                if (this.counter[i] != MultidimensionalCounter.this.size[i] - 1) {
                    return true;
                }
            }
            return false;
        }

        /* JADX WARN: Can't rename method to resolve collision */
        @Override // java.util.Iterator
        public Integer next() {
            int i = MultidimensionalCounter.this.last;
            while (true) {
                if (i >= 0) {
                    if (this.counter[i] == MultidimensionalCounter.this.size[i] - 1) {
                        this.counter[i] = 0;
                        i--;
                    } else {
                        int[] iArr = this.counter;
                        int i2 = i;
                        iArr[i2] = iArr[i2] + 1;
                        break;
                    }
                } else {
                    break;
                }
            }
            int i3 = this.count + 1;
            this.count = i3;
            return Integer.valueOf(i3);
        }

        public int getCount() {
            return this.count;
        }

        public int[] getCounts() {
            return MultidimensionalCounter.this.copyOf(this.counter, MultidimensionalCounter.this.dimension);
        }

        public int getCount(int dim) {
            return this.counter[dim];
        }

        @Override // java.util.Iterator
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    public MultidimensionalCounter(int... size) {
        this.dimension = size.length;
        this.size = copyOf(size, this.dimension);
        this.uniCounterOffset = new int[this.dimension];
        this.last = this.dimension - 1;
        int tS = size[this.last];
        for (int i = 0; i < this.last; i++) {
            int count = 1;
            for (int j = i + 1; j < this.dimension; j++) {
                count *= size[j];
            }
            this.uniCounterOffset[i] = count;
            tS *= size[i];
        }
        this.uniCounterOffset[this.last] = 0;
        if (tS <= 0) {
            throw new NotStrictlyPositiveException(Integer.valueOf(tS));
        }
        this.totalSize = tS;
    }

    @Override // java.lang.Iterable
    /* renamed from: iterator, reason: merged with bridge method [inline-methods] */
    public java.util.Iterator<Integer> iterator2() {
        return new Iterator();
    }

    public int getDimension() {
        return this.dimension;
    }

    public int[] getCounts(int index) {
        if (index < 0 || index >= this.totalSize) {
            throw new OutOfRangeException(Integer.valueOf(index), 0, Integer.valueOf(this.totalSize));
        }
        int[] indices = new int[this.dimension];
        int count = 0;
        for (int i = 0; i < this.last; i++) {
            int idx = 0;
            int offset = this.uniCounterOffset[i];
            while (count <= index) {
                count += offset;
                idx++;
            }
            count -= offset;
            indices[i] = idx - 1;
        }
        int idx2 = 1;
        while (count < index) {
            count += idx2;
            idx2++;
        }
        indices[this.last] = idx2 - 1;
        return indices;
    }

    public int getCount(int... c) throws OutOfRangeException {
        if (c.length != this.dimension) {
            throw new DimensionMismatchException(c.length, this.dimension);
        }
        int count = 0;
        for (int i = 0; i < this.dimension; i++) {
            int index = c[i];
            if (index < 0 || index >= this.size[i]) {
                throw new OutOfRangeException(Integer.valueOf(index), 0, Integer.valueOf(this.size[i] - 1));
            }
            count += this.uniCounterOffset[i] * c[i];
        }
        return count + c[this.last];
    }

    public int getSize() {
        return this.totalSize;
    }

    public int[] getSizes() {
        return copyOf(this.size, this.dimension);
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < this.dimension; i++) {
            sb.append("[").append(getCount(i)).append("]");
        }
        return sb.toString();
    }

    /* JADX INFO: Access modifiers changed from: private */
    public int[] copyOf(int[] source, int newLen) {
        int[] output = new int[newLen];
        System.arraycopy(source, 0, output, 0, Math.min(source.length, newLen));
        return output;
    }
}
