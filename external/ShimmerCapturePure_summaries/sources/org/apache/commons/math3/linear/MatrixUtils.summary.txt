// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math3/linear/MatrixUtils.java
// Size: 24842 bytes
// Modified: 2025-10-21 16:32:10.377129200 +0100

package org.apache.commons.math3.linear;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Array;
import java.util.Arrays;
import org.apache.commons.math3.Field;
import org.apache.commons.math3.FieldElement;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.MathArithmeticException;
import org.apache.commons.math3.exception.NoDataException;
import org.apache.commons.math3.exception.NullArgumentException;
import org.apache.commons.math3.exception.NumberIsTooSmallException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.exception.ZeroException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.fraction.BigFraction;
import org.apache.commons.math3.fraction.Fraction;
import org.apache.commons.math3.geometry.VectorFormat;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathArrays;
import org.apache.commons.math3.util.MathUtils;
import org.apache.commons.math3.util.Precision;

/* loaded from: classes5.dex */
public class MatrixUtils {
    public static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();
    public static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat("[", "]", "", "", VectorFormat.DEFAULT_SEPARATOR, ", ");

    private MatrixUtils() {
    }

    public static RealMatrix createRealMatrix(int i, int i2) {
        return i * i2 <= 4096 ? new Array2DRowRealMatrix(i, i2) : new BlockRealMatrix(i, i2);
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(Field<T> field, int i, int i2) {
        return i * i2 <= 4096 ? new Array2DRowFieldMatrix(field, i, i2) : new BlockFieldMatrix(field, i, i2);
    }

    public static RealMatrix createRealMatrix(double[][] dArr) throws NullArgumentException, NoDataException, DimensionMismatchException {
        double[] dArr2;
        if (dArr == null || (dArr2 = dArr[0]) == null) {
            throw new NullArgumentException();
        }
        return dArr.length * dArr2.length <= 4096 ? new Array2DRowRealMatrix(dArr) : new BlockRealMatrix(dArr);
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] tArr) throws NullArgumentException, NoDataException, DimensionMismatchException {
        T[] tArr2;
        if (tArr == null || (tArr2 = tArr[0]) == null) {
            throw new NullArgumentException();
        }
        return tArr.length * tArr2.length <= 4096 ? new Array2DRowFieldMatrix(tArr) : new BlockFieldMatrix(tArr);
    }

    public static RealMatrix createRealIdentityMatrix(int i) throws OutOfRangeException {
        RealMatrix realMatrixCreateRealMatrix = createRealMatrix(i, i);
        for (int i2 = 0; i2 < i; i2++) {
            realMatrixCreateRealMatrix.setEntry(i2, i2, 1.0d);
        }
        return realMatrixCreateRealMatrix;
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(Field<T> field, int i) {
        T zero = field.getZero();
        T one = field.getOne();
        FieldElement[][] fieldElementArr = (FieldElement[][]) MathArrays.buildArray(field, i, i);
        for (int i2 = 0; i2 < i; i2++) {
            FieldElement[] fieldElementArr2 = fieldElementArr[i2];
            Arrays.fill(fieldElementArr2, zero);
            fieldElementArr2[i2] = one;
        }
        return new Array2DRowFieldMatrix((Field) field, fieldElementArr, false);
    }

    public static RealMatrix createRealDiagonalMatrix(double[] dArr) throws OutOfRangeException {
        RealMatrix realMatrixCreateRealMatrix = createRealMatrix(dArr.length, dArr.length);
        for (int i = 0; i < dArr.length; i++) {
            realMatrixCreateRealMatrix.setEntry(i, i, dArr[i]);
        }
        return realMatrixCreateRealMatrix;
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(T[] tArr) throws OutOfRangeException {
        FieldMatrix<T> fieldMatrixCreateFieldMatrix = createFieldMatrix(tArr[0].getField(), tArr.length, tArr.length);
        for (int i = 0; i < tArr.length; i++) {
            fieldMatrixCreateFieldMatrix.setEntry(i, i, tArr[i]);
        }
        return fieldMatrixCreateFieldMatrix;
    }

    public static RealVector createRealVector(double[] dArr) throws NullArgumentException, NoDataException {
        if (dArr == null) {
            throw new NullArgumentException();
        }
        return new ArrayRealVector(dArr, true);
    }

    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(T[] tArr) throws NullArgumentException, ZeroException, NoDataException {
        if (tArr == null) {
            throw new NullArgumentException();
        }
        if (tArr.length == 0) {
            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT, new Object[0]);
        }
        return new ArrayFieldVector(tArr[0].getField(), (FieldElement[]) tArr, true);
    }

    public static RealMatrix createRowRealMatrix(double[] dArr) throws OutOfRangeException, NullArgumentException, NoDataException {
        if (dArr == null) {
            throw new NullArgumentException();
        }
        int length = dArr.length;
        RealMatrix realMatrixCreateRealMatrix = createRealMatrix(1, length);
        for (int i = 0; i < length; i++) {
            realMatrixCreateRealMatrix.setEntry(0, i, dArr[i]);
        }
        return realMatrixCreateRealMatrix;
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(T[] tArr) throws OutOfRangeException, NullArgumentException, NoDataException {
        if (tArr == null) {
            throw new NullArgumentException();
        }
        int length = tArr.length;
        if (length == 0) {
            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);
        }
        FieldMatrix<T> fieldMatrixCreateFieldMatrix = createFieldMatrix(tArr[0].getField(), 1, length);
        for (int i = 0; i < length; i++) {
            fieldMatrixCreateFieldMatrix.setEntry(0, i, tArr[i]);
        }
        return fieldMatrixCreateFieldMatrix;
    }

    public static RealMatrix createColumnRealMatrix(double[] dArr) throws OutOfRangeException, NullArgumentException, NoDataException {
        if (dArr == null) {
            throw new NullArgumentException();
        }
        int length = dArr.length;
        RealMatrix realMatrixCreateRealMatrix = createRealMatrix(length, 1);
        for (int i = 0; i < length; i++) {
            realMatrixCreateRealMatrix.setEntry(i, 0, dArr[i]);
        }
        return realMatrixCreateRealMatrix;
    }

    public static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(T[] tArr) throws OutOfRangeException, NullArgumentException, NoDataException {
        if (tArr == null) {
            throw new NullArgumentException();
        }
        int length = tArr.length;
        if (length == 0) {
            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);
        }
        FieldMatrix<T> fieldMatrixCreateFieldMatrix = createFieldMatrix(tArr[0].getField(), length, 1);
        for (int i = 0; i < length; i++) {
            fieldMatrixCreateFieldMatrix.setEntry(i, 0, tArr[i]);
        }
        return fieldMatrixCreateFieldMatrix;
    }

    private static boolean isSymmetricInternal(RealMatrix realMatrix, double d, boolean z) throws OutOfRangeException {
        int rowDimension = realMatrix.getRowDimension();
        if (rowDimension != realMatrix.getColumnDimension()) {
            if (z) {
                throw new NonSquareMatrixException(rowDimension, realMatrix.getColumnDimension());
            }
            return false;
        }
        int i = 0;
        while (i < rowDimension) {
            int i2 = i + 1;
            for (int i3 = i2; i3 < rowDimension; i3++) {
                double entry = realMatrix.getEntry(i, i3);
                double entry2 = realMatrix.getEntry(i3, i);
                if (FastMath.abs(entry - entry2) > FastMath.max(FastMath.abs(entry), FastMath.abs(entry2)) * d) {
                    if (z) {
                        throw new NonSymmetricMatrixException(i, i3, d);
                    }
                    return false;
                }
            }
            i = i2;
        }
        return true;
    }

    public static void checkSymmetric(RealMatrix realMatrix, double d) throws OutOfRangeException {
        isSymmetricInternal(realMatrix, d, true);
    }

    public static boolean isSymmetric(RealMatrix realMatrix, double d) {
        return isSymmetricInternal(realMatrix, d, false);
    }

    public static void checkMatrixIndex(AnyMatrix anyMatrix, int i, int i2) throws OutOfRangeException {
        checkRowIndex(anyMatrix, i);
        checkColumnIndex(anyMatrix, i2);
    }

    public static void checkRowIndex(AnyMatrix anyMatrix, int i) throws OutOfRangeException {
        if (i < 0 || i >= anyMatrix.getRowDimension()) {
            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX, Integer.valueOf(i), 0, Integer.valueOf(anyMatrix.getRowDimension() - 1));
        }
    }

    public static void checkColumnIndex(AnyMatrix anyMatrix, int i) throws OutOfRangeException {
        if (i < 0 || i >= anyMatrix.getColumnDimension()) {
            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX, Integer.valueOf(i), 0, Integer.valueOf(anyMatrix.getColumnDimension() - 1));
        }
    }

    public static void checkSubMatrixIndex(AnyMatrix anyMatrix, int i, int i2, int i3, int i4) throws NumberIsTooSmallException, OutOfRangeException {
        checkRowIndex(anyMatrix, i);
        checkRowIndex(anyMatrix, i2);
        if (i2 < i) {
            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW, Integer.valueOf(i2), Integer.valueOf(i), false);
        }
        checkColumnIndex(anyMatrix, i3);
        checkColumnIndex(anyMatrix, i4);
        if (i4 < i3) {
            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN, Integer.valueOf(i4), Integer.valueOf(i3), false);
        }
    }

    public static void checkSubMatrixIndex(AnyMatrix anyMatrix, int[] iArr, int[] iArr2) throws OutOfRangeException, NullArgumentException, NoDataException {
        if (iArr == null) {
            throw new NullArgumentException();
        }
        if (iArr2 == null) {
            throw new NullArgumentException();
        }
        if (iArr.length == 0) {
            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);
        }
        if (iArr2.length == 0) {
            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);
        }
        for (int i : iArr) {
            checkRowIndex(anyMatrix, i);
        }
        for (int i2 : iArr2) {
            checkColumnIndex(anyMatrix, i2);
        }
    }

    public static void checkAdditionCompatible(AnyMatrix anyMatrix, AnyMatrix anyMatrix2) throws MatrixDimensionMismatchException {
        if (anyMatrix.getRowDimension() != anyMatrix2.getRowDimension() || anyMatrix.getColumnDimension() != anyMatrix2.getColumnDimension()) {
            throw new MatrixDimensionMismatchException(anyMatrix.getRowDimension(), anyMatrix.getColumnDimension(), anyMatrix2.getRowDimension(), anyMatrix2.getColumnDimension());
        }
    }

    public static void checkSubtractionCompatible(AnyMatrix anyMatrix, AnyMatrix anyMatrix2) throws MatrixDimensionMismatchException {
        if (anyMatrix.getRowDimension() != anyMatrix2.getRowDimension() || anyMatrix.getColumnDimension() != anyMatrix2.getColumnDimension()) {
            throw new MatrixDimensionMismatchException(anyMatrix.getRowDimension(), anyMatrix.getColumnDimension(), anyMatrix2.getRowDimension(), anyMatrix2.getColumnDimension());
        }
    }

    public static void checkMultiplicationCompatible(AnyMatrix anyMatrix, AnyMatrix anyMatrix2) throws DimensionMismatchException {
        if (anyMatrix.getColumnDimension() != anyMatrix2.getRowDimension()) {
            throw new DimensionMismatchException(anyMatrix.getColumnDimension(), anyMatrix2.getRowDimension());
        }
    }

    public static Array2DRowRealMatrix fractionMatrixToRealMatrix(FieldMatrix<Fraction> fieldMatrix) {
        FractionMatrixConverter fractionMatrixConverter = new FractionMatrixConverter();
        fieldMatrix.walkInOptimizedOrder(fractionMatrixConverter);
        return fractionMatrixConverter.getConvertedMatrix();
    }

    private static class FractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<Fraction> {
        private double[][] data;

        FractionMatrixConverter() {
            super(Fraction.ZERO);
        }

        @Override // org.apache.commons.math3.linear.DefaultFieldMatrixPreservingVisitor, org.apache.commons.math3.linear.FieldMatrixPreservingVisitor
        public void start(int i, int i2, int i3, int i4, int i5, int i6) {
            this.data = (double[][]) Array.newInstance((Class<?>) Double.TYPE, i, i2);
        }

        @Override // org.apache.commons.math3.linear.DefaultFieldMatrixPreservingVisitor, org.apache.commons.math3.linear.FieldMatrixPreservingVisitor
        public void visit(int i, int i2, Fraction fraction) {
            this.data[i][i2] = fraction.doubleValue();
        }

        Array2DRowRealMatrix getConvertedMatrix() {
            return new Array2DRowRealMatrix(this.data, false);
        }
    }

    public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(FieldMatrix<BigFraction> fieldMatrix) {
        BigFractionMatrixConverter bigFractionMatrixConverter = new BigFractionMatrixConverter();
        fieldMatrix.walkInOptimizedOrder(bigFractionMatrixConverter);
        return bigFractionMatrixConverter.getConvertedMatrix();
    }

    private static class BigFractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<BigFraction> {
        private double[][] data;

        BigFractionMatrixConverter() {
            super(BigFraction.ZERO);
        }

        @Override // org.apache.commons.math3.linear.DefaultFieldMatrixPreservingVisitor, org.apache.commons.math3.linear.FieldMatrixPreservingVisitor
        public void start(int i, int i2, int i3, int i4, int i5, int i6) {
            this.data = (double[][]) Array.newInstance((Class<?>) Double.TYPE, i, i2);
        }

        @Override // org.apache.commons.math3.linear.DefaultFieldMatrixPreservingVisitor, org.apache.commons.math3.linear.FieldMatrixPreservingVisitor
        public void visit(int i, int i2, BigFraction bigFraction) {
            this.data[i][i2] = bigFraction.doubleValue();
        }

        Array2DRowRealMatrix getConvertedMatrix() {
            return new Array2DRowRealMatrix(this.data, false);
        }
    }

    public static void serializeRealVector(RealVector realVector, ObjectOutputStream objectOutputStream) throws IOException {
        int dimension = realVector.getDimension();
        objectOutputStream.writeInt(dimension);
        for (int i = 0; i < dimension; i++) {
            objectOutputStream.writeDouble(realVector.getEntry(i));
        }
    }

    public static void deserializeRealVector(Object obj, String str, ObjectInputStream objectInputStream) throws IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException, IllegalArgumentException {
        try {
            int i = objectInputStream.readInt();
            double[] dArr = new double[i];
            for (int i2 = 0; i2 < i; i2++) {
                dArr[i2] = objectInputStream.readDouble();
            }
            ArrayRealVector arrayRealVector = new ArrayRealVector(dArr, false);
            java.lang.reflect.Field declaredField = obj.getClass().getDeclaredField(str);
            declaredField.setAccessible(true);
            declaredField.set(obj, arrayRealVector);
        } catch (IllegalAccessException e) {
            IOException iOException = new IOException();
            iOException.initCause(e);
            throw iOException;
        } catch (NoSuchFieldException e2) {
            IOException iOException2 = new IOException();
            iOException2.initCause(e2);
            throw iOException2;
        }
    }

    public static void serializeRealMatrix(RealMatrix realMatrix, ObjectOutputStream objectOutputStream) throws IOException {
        int rowDimension = realMatrix.getRowDimension();
        int columnDimension = realMatrix.getColumnDimension();
        objectOutputStream.writeInt(rowDimension);
        objectOutputStream.writeInt(columnDimension);
        for (int i = 0; i < rowDimension; i++) {
            for (int i2 = 0; i2 < columnDimension; i2++) {
                objectOutputStream.writeDouble(realMatrix.getEntry(i, i2));
            }
        }
    }

    public static void deserializeRealMatrix(Object obj, String str, ObjectInputStream objectInputStream) throws IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException, IllegalArgumentException {
        try {
            int i = objectInputStream.readInt();
            int i2 = objectInputStream.readInt();
            double[][] dArr = (double[][]) Array.newInstance((Class<?>) Double.TYPE, i, i2);
            for (int i3 = 0; i3 < i; i3++) {
                double[] dArr2 = dArr[i3];
                for (int i4 = 0; i4 < i2; i4++) {
                    dArr2[i4] = objectInputStream.readDouble();
                }
            }
            Array2DRowRealMatrix array2DRowRealMatrix = new Array2DRowRealMatrix(dArr, false);
            java.lang.reflect.Field declaredField = obj.getClass().getDeclaredField(str);
            declaredField.setAccessible(true);
            declaredField.set(obj, array2DRowRealMatrix);
        } catch (IllegalAccessException e) {
            IOException iOException = new IOException();
            iOException.initCause(e);
            throw iOException;
        } catch (NoSuchFieldException e2) {
            IOException iOException2 = new IOException();
            iOException2.initCause(e2);
            throw iOException2;
        }
    }

    public static void solveLowerTriangularSystem(RealMatrix realMatrix, RealVector realVector) throws OutOfRangeException, DimensionMismatchException, MathArithmeticException {
        if (realMatrix == null || realVector == null || realMatrix.getRowDimension() != realVector.getDimension()) {
            throw new DimensionMismatchException(realMatrix == null ? 0 : realMatrix.getRowDimension(), realVector != null ? realVector.getDimension() : 0);
        }
        if (realMatrix.getColumnDimension() != realMatrix.getRowDimension()) {
            throw new NonSquareMatrixException(realMatrix.getRowDimension(), realMatrix.getColumnDimension());
        }
        int rowDimension = realMatrix.getRowDimension();
        int i = 0;
        while (i < rowDimension) {
            double entry = realMatrix.getEntry(i, i);
            if (FastMath.abs(entry) < Precision.SAFE_MIN) {
                throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR, new Object[0]);
            }
            double entry2 = realVector.getEntry(i) / entry;
            realVector.setEntry(i, entry2);
            int i2 = i + 1;
            for (int i3 = i2; i3 < rowDimension; i3++) {
                realVector.setEntry(i3, realVector.getEntry(i3) - (realMatrix.getEntry(i3, i) * entry2));
            }
            i = i2;
        }
    }

    public static void solveUpperTriangularSystem(RealMatrix realMatrix, RealVector realVector) throws OutOfRangeException, DimensionMismatchException, MathArithmeticException {
        if (realMatrix == null || realVector == null || realMatrix.getRowDimension() != realVector.getDimension()) {
            throw new DimensionMismatchException(realMatrix == null ? 0 : realMatrix.getRowDimension(), realVector != null ? realVector.getDimension() : 0);
        }
        if (realMatrix.getColumnDimension() != realMatrix.getRowDimension()) {
            throw new NonSquareMatrixException(realMatrix.getRowDimension(), realMatrix.getColumnDimension());
        }
        int rowDimension = realMatrix.getRowDimension();
        while (true) {
            rowDimension--;
            if (rowDimension <= -1) {
                return;
            }
            double entry = realMatrix.getEntry(rowDimension, rowDimension);
            if (FastMath.abs(entry) < Precision.SAFE_MIN) {
                throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR, new Object[0]);
            }
            double entry2 = realVector.getEntry(rowDimension) / entry;
            realVector.setEntry(rowDimension, entry2);
            for (int i = rowDimension - 1; i > -1; i--) {
                realVector.setEntry(i, realVector.getEntry(i) - (realMatrix.getEntry(i, rowDimension) * entry2));
            }
        }
    }

    public static RealMatrix blockInverse(RealMatrix realMatrix, int i) throws NumberIsTooSmallException, OutOfRangeException, NullArgumentException, NoDataException, SingularMatrixException, DimensionMismatchException {
        int rowDimension = realMatrix.getRowDimension();
        if (realMatrix.getColumnDimension() != rowDimension) {
            throw new NonSquareMatrixException(realMatrix.getRowDimension(), realMatrix.getColumnDimension());
        }
        int i2 = i + 1;
        RealMatrix subMatrix = realMatrix.getSubMatrix(0, i, 0, i);
        int i3 = rowDimension - 1;
        RealMatrix subMatrix2 = realMatrix.getSubMatrix(0, i, i2, i3);
        RealMatrix subMatrix3 = realMatrix.getSubMatrix(i2, i3, 0, i);
        RealMatrix subMatrix4 = realMatrix.getSubMatrix(i2, i3, i2, i3);
        DecompositionSolver solver = new SingularValueDecomposition(subMatrix).getSolver();
        if (!solver.isNonSingular()) {
            throw new SingularMatrixException();
        }
        RealMatrix inverse = solver.getInverse();
        DecompositionSolver solver2 = new SingularValueDecomposition(subMatrix4).getSolver();
        if (!solver2.isNonSingular()) {
            throw new SingularMatrixException();
        }
        RealMatrix inverse2 = solver2.getInverse();
        DecompositionSolver solver3 = new SingularValueDecomposition(subMatrix.subtract(subMatrix2.multiply(inverse2).multiply(subMatrix3))).getSolver();
        if (!solver3.isNonSingular()) {
            throw new SingularMatrixException();
        }
        RealMatrix inverse3 = solver3.getInverse();
        DecompositionSolver solver4 = new SingularValueDecomposition(subMatrix4.subtract(subMatrix3.multiply(inverse).multiply(subMatrix2))).getSolver();
        if (!solver4.isNonSingular()) {
            throw new SingularMatrixException();
        }
        RealMatrix inverse4 = solver4.getInverse();
        RealMatrix realMatrixScalarMultiply = inverse.multiply(subMatrix2).multiply(inverse4).scalarMultiply(-1.0d);
        RealMatrix realMatrixScalarMultiply2 = inverse2.multiply(subMatrix3).multiply(inverse3).scalarMultiply(-1.0d);
        Array2DRowRealMatrix array2DRowRealMatrix = new Array2DRowRealMatrix(rowDimension, rowDimension);
        array2DRowRealMatrix.setSubMatrix(inverse3.getData(), 0, 0);
        array2DRowRealMatrix.setSubMatrix(realMatrixScalarMultiply.getData(), 0, i2);
        array2DRowRealMatrix.setSubMatrix(realMatrixScalarMultiply2.getData(), i2, 0);
        array2DRowRealMatrix.setSubMatrix(inverse4.getData(), i2, i2);
        return array2DRowRealMatrix;
    }

    public static RealMatrix inverse(RealMatrix realMatrix) throws NullArgumentException, NonSquareMatrixException, SingularMatrixException {
        return inverse(realMatrix, 0.0d);
    }

    public static RealMatrix inverse(RealMatrix realMatrix, double d) throws NullArgumentException, NonSquareMatrixException, SingularMatrixException {
        MathUtils.checkNotNull(realMatrix);
        if (!realMatrix.isSquare()) {
            throw new NonSquareMatrixException(realMatrix.getRowDimension(), realMatrix.getColumnDimension());
        }
        if (realMatrix instanceof DiagonalMatrix) {
            return ((DiagonalMatrix) realMatrix).inverse(d);
        }
        return new QRDecomposition(realMatrix, d).getSolver().getInverse();
    }
}
