// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math3/linear/OpenMapRealMatrix.java
// Size: 9158 bytes
// Modified: 2025-10-21 16:32:12.465588400 +0100

package org.apache.commons.math3.linear;

import java.io.Serializable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.NumberIsTooLargeException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.util.OpenIntToDoubleHashMap;

/* loaded from: classes5.dex */
public class OpenMapRealMatrix extends AbstractRealMatrix implements SparseRealMatrix, Serializable {
    private static final long serialVersionUID = -5962461716457143437L;
    private final int columns;
    private final OpenIntToDoubleHashMap entries;
    private final int rows;

    private int computeKey(int i, int i2) {
        return (i * this.columns) + i2;
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealLinearOperator, org.apache.commons.math3.linear.AnyMatrix
    public int getColumnDimension() {
        return this.columns;
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealLinearOperator, org.apache.commons.math3.linear.AnyMatrix
    public int getRowDimension() {
        return this.rows;
    }

    public OpenMapRealMatrix(int i, int i2) throws NotStrictlyPositiveException, NumberIsTooLargeException {
        super(i, i2);
        long j = i * i2;
        if (j >= 2147483647L) {
            throw new NumberIsTooLargeException(Long.valueOf(j), Integer.MAX_VALUE, false);
        }
        this.rows = i;
        this.columns = i2;
        this.entries = new OpenIntToDoubleHashMap(0.0d);
    }

    public OpenMapRealMatrix(OpenMapRealMatrix openMapRealMatrix) {
        this.rows = openMapRealMatrix.rows;
        this.columns = openMapRealMatrix.columns;
        this.entries = new OpenIntToDoubleHashMap(openMapRealMatrix.entries);
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public OpenMapRealMatrix copy() {
        return new OpenMapRealMatrix(this);
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public OpenMapRealMatrix createMatrix(int i, int i2) throws NotStrictlyPositiveException, NumberIsTooLargeException {
        return new OpenMapRealMatrix(i, i2);
    }

    public OpenMapRealMatrix add(OpenMapRealMatrix openMapRealMatrix) throws OutOfRangeException, MatrixDimensionMismatchException, NoSuchElementException, ConcurrentModificationException {
        MatrixUtils.checkAdditionCompatible(this, openMapRealMatrix);
        OpenMapRealMatrix openMapRealMatrix2 = new OpenMapRealMatrix(this);
        OpenIntToDoubleHashMap.Iterator it2 = openMapRealMatrix.entries.iterator();
        while (it2.hasNext()) {
            it2.advance();
            int iKey = it2.key() / this.columns;
            int iKey2 = it2.key() - (this.columns * iKey);
            openMapRealMatrix2.setEntry(iKey, iKey2, getEntry(iKey, iKey2) + it2.value());
        }
        return openMapRealMatrix2;
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public OpenMapRealMatrix subtract(RealMatrix realMatrix) throws MatrixDimensionMismatchException {
        try {
            return subtract((OpenMapRealMatrix) realMatrix);
        } catch (ClassCastException unused) {
            return (OpenMapRealMatrix) super.subtract(realMatrix);
        }
    }

    public OpenMapRealMatrix subtract(OpenMapRealMatrix openMapRealMatrix) throws OutOfRangeException, MatrixDimensionMismatchException, NoSuchElementException, ConcurrentModificationException {
        MatrixUtils.checkAdditionCompatible(this, openMapRealMatrix);
        OpenMapRealMatrix openMapRealMatrix2 = new OpenMapRealMatrix(this);
        OpenIntToDoubleHashMap.Iterator it2 = openMapRealMatrix.entries.iterator();
        while (it2.hasNext()) {
            it2.advance();
            int iKey = it2.key() / this.columns;
            int iKey2 = it2.key() - (this.columns * iKey);
            openMapRealMatrix2.setEntry(iKey, iKey2, getEntry(iKey, iKey2) - it2.value());
        }
        return openMapRealMatrix2;
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public RealMatrix multiply(RealMatrix realMatrix) throws OutOfRangeException, DimensionMismatchException, NoSuchElementException, ConcurrentModificationException, NumberIsTooLargeException {
        try {
            return multiply((OpenMapRealMatrix) realMatrix);
        } catch (ClassCastException unused) {
            MatrixUtils.checkMultiplicationCompatible(this, realMatrix);
            int columnDimension = realMatrix.getColumnDimension();
            BlockRealMatrix blockRealMatrix = new BlockRealMatrix(this.rows, columnDimension);
            OpenIntToDoubleHashMap.Iterator it2 = this.entries.iterator();
            while (it2.hasNext()) {
                it2.advance();
                double dValue = it2.value();
                int iKey = it2.key();
                int i = this.columns;
                int i2 = iKey / i;
                int i3 = iKey % i;
                for (int i4 = 0; i4 < columnDimension; i4++) {
                    blockRealMatrix.addToEntry(i2, i4, realMatrix.getEntry(i3, i4) * dValue);
                }
            }
            return blockRealMatrix;
        }
    }

    public OpenMapRealMatrix multiply(OpenMapRealMatrix openMapRealMatrix) throws DimensionMismatchException, NoSuchElementException, ConcurrentModificationException, NumberIsTooLargeException {
        MatrixUtils.checkMultiplicationCompatible(this, openMapRealMatrix);
        int columnDimension = openMapRealMatrix.getColumnDimension();
        OpenMapRealMatrix openMapRealMatrix2 = new OpenMapRealMatrix(this.rows, columnDimension);
        OpenIntToDoubleHashMap.Iterator it2 = this.entries.iterator();
        while (it2.hasNext()) {
            it2.advance();
            double dValue = it2.value();
            int iKey = it2.key();
            int i = this.columns;
            int i2 = iKey / i;
            int i3 = iKey % i;
            for (int i4 = 0; i4 < columnDimension; i4++) {
                int iComputeKey = openMapRealMatrix.computeKey(i3, i4);
                if (openMapRealMatrix.entries.containsKey(iComputeKey)) {
                    int iComputeKey2 = openMapRealMatrix2.computeKey(i2, i4);
                    double d = openMapRealMatrix2.entries.get(iComputeKey2) + (openMapRealMatrix.entries.get(iComputeKey) * dValue);
                    if (d == 0.0d) {
                        openMapRealMatrix2.entries.remove(iComputeKey2);
                    } else {
                        openMapRealMatrix2.entries.put(iComputeKey2, d);
                    }
                }
            }
        }
        return openMapRealMatrix2;
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public double getEntry(int i, int i2) throws OutOfRangeException {
        MatrixUtils.checkRowIndex(this, i);
        MatrixUtils.checkColumnIndex(this, i2);
        return this.entries.get(computeKey(i, i2));
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public void setEntry(int i, int i2, double d) throws OutOfRangeException {
        MatrixUtils.checkRowIndex(this, i);
        MatrixUtils.checkColumnIndex(this, i2);
        if (d == 0.0d) {
            this.entries.remove(computeKey(i, i2));
        } else {
            this.entries.put(computeKey(i, i2), d);
        }
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public void addToEntry(int i, int i2, double d) throws OutOfRangeException {
        MatrixUtils.checkRowIndex(this, i);
        MatrixUtils.checkColumnIndex(this, i2);
        int iComputeKey = computeKey(i, i2);
        double d2 = this.entries.get(iComputeKey) + d;
        if (d2 == 0.0d) {
            this.entries.remove(iComputeKey);
        } else {
            this.entries.put(iComputeKey, d2);
        }
    }

    @Override // org.apache.commons.math3.linear.AbstractRealMatrix, org.apache.commons.math3.linear.RealMatrix
    public void multiplyEntry(int i, int i2, double d) throws OutOfRangeException {
        MatrixUtils.checkRowIndex(this, i);
        MatrixUtils.checkColumnIndex(this, i2);
        int iComputeKey = computeKey(i, i2);
        double d2 = this.entries.get(iComputeKey) * d;
        if (d2 == 0.0d) {
            this.entries.remove(iComputeKey);
        } else {
            this.entries.put(iComputeKey, d2);
        }
    }
}
