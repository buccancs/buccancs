// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math3/distribution/ZipfDistribution.java
// Size: 7950 bytes
// Modified: 2025-10-21 16:32:08.164999800 +0100

package org.apache.commons.math3.distribution;

import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well19937c;
import org.apache.commons.math3.util.FastMath;

/* loaded from: classes5.dex */
public class ZipfDistribution extends AbstractIntegerDistribution {
    private static final long serialVersionUID = -140627372283420404L;
    private final double exponent;
    private final int numberOfElements;
    private double numericalMean;
    private boolean numericalMeanIsCalculated;
    private double numericalVariance;
    private boolean numericalVarianceIsCalculated;
    private transient ZipfRejectionInversionSampler sampler;

    public double getExponent() {
        return this.exponent;
    }

    public int getNumberOfElements() {
        return this.numberOfElements;
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public int getSupportLowerBound() {
        return 1;
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public boolean isSupportConnected() {
        return true;
    }

    public ZipfDistribution(int i, double d) {
        this(new Well19937c(), i, d);
    }

    public ZipfDistribution(RandomGenerator randomGenerator, int i, double d) throws NotStrictlyPositiveException {
        super(randomGenerator);
        this.numericalMean = Double.NaN;
        this.numericalMeanIsCalculated = false;
        this.numericalVariance = Double.NaN;
        this.numericalVarianceIsCalculated = false;
        if (i <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION, Integer.valueOf(i));
        }
        if (d <= 0.0d) {
            throw new NotStrictlyPositiveException(LocalizedFormats.EXPONENT, Double.valueOf(d));
        }
        this.numberOfElements = i;
        this.exponent = d;
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public double probability(int i) {
        if (i <= 0 || i > this.numberOfElements) {
            return 0.0d;
        }
        return (1.0d / FastMath.pow(i, this.exponent)) / generalizedHarmonic(this.numberOfElements, this.exponent);
    }

    @Override // org.apache.commons.math3.distribution.AbstractIntegerDistribution
    public double logProbability(int i) {
        if (i <= 0 || i > this.numberOfElements) {
            return Double.NEGATIVE_INFINITY;
        }
        double d = -FastMath.log(i);
        double d2 = this.exponent;
        return (d * d2) - FastMath.log(generalizedHarmonic(this.numberOfElements, d2));
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public double cumulativeProbability(int i) {
        if (i <= 0) {
            return 0.0d;
        }
        if (i >= this.numberOfElements) {
            return 1.0d;
        }
        return generalizedHarmonic(i, this.exponent) / generalizedHarmonic(this.numberOfElements, this.exponent);
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public double getNumericalMean() {
        if (!this.numericalMeanIsCalculated) {
            this.numericalMean = calculateNumericalMean();
            this.numericalMeanIsCalculated = true;
        }
        return this.numericalMean;
    }

    protected double calculateNumericalMean() {
        int numberOfElements = getNumberOfElements();
        double exponent = getExponent();
        return generalizedHarmonic(numberOfElements, exponent - 1.0d) / generalizedHarmonic(numberOfElements, exponent);
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public double getNumericalVariance() {
        if (!this.numericalVarianceIsCalculated) {
            this.numericalVariance = calculateNumericalVariance();
            this.numericalVarianceIsCalculated = true;
        }
        return this.numericalVariance;
    }

    protected double calculateNumericalVariance() {
        int numberOfElements = getNumberOfElements();
        double exponent = getExponent();
        double dGeneralizedHarmonic = generalizedHarmonic(numberOfElements, exponent - 2.0d);
        double dGeneralizedHarmonic2 = generalizedHarmonic(numberOfElements, exponent - 1.0d);
        double dGeneralizedHarmonic3 = generalizedHarmonic(numberOfElements, exponent);
        return (dGeneralizedHarmonic / dGeneralizedHarmonic3) - ((dGeneralizedHarmonic2 * dGeneralizedHarmonic2) / (dGeneralizedHarmonic3 * dGeneralizedHarmonic3));
    }

    private double generalizedHarmonic(int i, double d) {
        double dPow = 0.0d;
        while (i > 0) {
            dPow += 1.0d / FastMath.pow(i, d);
            i--;
        }
        return dPow;
    }

    @Override // org.apache.commons.math3.distribution.IntegerDistribution
    public int getSupportUpperBound() {
        return getNumberOfElements();
    }

    @Override // org.apache.commons.math3.distribution.AbstractIntegerDistribution, org.apache.commons.math3.distribution.IntegerDistribution
    public int sample() {
        if (this.sampler == null) {
            this.sampler = new ZipfRejectionInversionSampler(this.numberOfElements, this.exponent);
        }
        return this.sampler.sample(this.random);
    }

    static final class ZipfRejectionInversionSampler {
        private final double exponent;
        private final double hIntegralNumberOfElements;
        private final int numberOfElements;
        private final double hIntegralX1 = hIntegral(1.5d) - 1.0d;
        private final double s = 2.0d - hIntegralInverse(hIntegral(2.5d) - h(2.0d));

        ZipfRejectionInversionSampler(int i, double d) {
            this.exponent = d;
            this.numberOfElements = i;
            this.hIntegralNumberOfElements = hIntegral(i + 0.5d);
        }

        int sample(RandomGenerator randomGenerator) {
            double dNextDouble;
            int i;
            double d;
            do {
                dNextDouble = this.hIntegralNumberOfElements + (randomGenerator.nextDouble() * (this.hIntegralX1 - this.hIntegralNumberOfElements));
                double dHIntegralInverse = hIntegralInverse(dNextDouble);
                i = (int) (dHIntegralInverse + 0.5d);
                if (i < 1) {
                    i = 1;
                } else {
                    int i2 = this.numberOfElements;
                    if (i > i2) {
                        i = i2;
                    }
                }
                d = i;
                if (d - dHIntegralInverse <= this.s) {
                    break;
                }
            } while (dNextDouble < hIntegral(0.5d + d) - h(d));
            return i;
        }

        private double hIntegral(double d) {
            double dLog = FastMath.log(d);
            return helper2((1.0d - this.exponent) * dLog) * dLog;
        }

        private double h(double d) {
            return FastMath.exp((-this.exponent) * FastMath.log(d));
        }

        private double hIntegralInverse(double d) {
            double d2 = (1.0d - this.exponent) * d;
            if (d2 < -1.0d) {
                d2 = -1.0d;
            }
            return FastMath.exp(helper1(d2) * d);
        }

        static double helper1(double d) {
            return FastMath.abs(d) > 1.0E-8d ? FastMath.log1p(d) / d : 1.0d - (d * (0.5d - ((0.3333333333333333d - (0.25d * d)) * d)));
        }

        static double helper2(double d) {
            return FastMath.abs(d) > 1.0E-8d ? FastMath.expm1(d) / d : (0.5d * d * ((0.3333333333333333d * d * ((d * 0.25d) + 1.0d)) + 1.0d)) + 1.0d;
        }
    }
}
