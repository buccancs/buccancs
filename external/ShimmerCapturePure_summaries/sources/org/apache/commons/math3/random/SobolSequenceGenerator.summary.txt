// Summary for: /mnt/c/dev/buccancs/external/ShimmerCapturePure/sources/org/apache/commons/math3/random/SobolSequenceGenerator.java
// Size: 7074 bytes
// Modified: 2025-10-21 16:32:08.048040100 +0100

package org.apache.commons.math3.random;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.math3.exception.MathInternalError;
import org.apache.commons.math3.exception.MathParseException;
import org.apache.commons.math3.exception.NotPositiveException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.util.FastMath;

/* loaded from: classes5.dex */
public class SobolSequenceGenerator implements RandomVectorGenerator {
    private static final int BITS = 52;
    private static final String FILE_CHARSET = "US-ASCII";
    private static final int MAX_DIMENSION = 1000;
    private static final String RESOURCE_NAME = "/assets/org/apache/commons/math3/random/new-joe-kuo-6.1000";
    private static final double SCALE = FastMath.pow(2.0d, 52);
    private int count = 0;
    private final int dimension;
    private final long[][] direction;
    private final long[] x;

    public int getNextIndex() {
        return this.count;
    }

    public SobolSequenceGenerator(int i) throws OutOfRangeException, IOException {
        if (i < 1 || i > 1000) {
            throw new OutOfRangeException(Integer.valueOf(i), 1, 1000);
        }
        InputStream resourceAsStream = getClass().getResourceAsStream(RESOURCE_NAME);
        if (resourceAsStream == null) {
            throw new MathInternalError();
        }
        this.dimension = i;
        this.direction = (long[][]) Array.newInstance((Class<?>) Long.TYPE, i, 53);
        this.x = new long[i];
        try {
            try {
                try {
                    initFromStream(resourceAsStream);
                } catch (IOException unused) {
                    throw new MathInternalError();
                }
            } catch (MathParseException unused2) {
                throw new MathInternalError();
            }
        } finally {
            try {
                resourceAsStream.close();
            } catch (IOException unused3) {
            }
        }
    }

    public SobolSequenceGenerator(int i, InputStream inputStream) throws NotStrictlyPositiveException, MathParseException, IOException {
        if (i < 1) {
            throw new NotStrictlyPositiveException(Integer.valueOf(i));
        }
        this.dimension = i;
        this.direction = (long[][]) Array.newInstance((Class<?>) Long.TYPE, i, 53);
        this.x = new long[i];
        int iInitFromStream = initFromStream(inputStream);
        if (iInitFromStream < i) {
            throw new OutOfRangeException(Integer.valueOf(i), 1, Integer.valueOf(iInitFromStream));
        }
    }

    private int initFromStream(InputStream inputStream) throws MathParseException, IOException {
        for (int i = 1; i <= 52; i++) {
            this.direction[0][i] = 1 << (52 - i);
        }
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName("US-ASCII")));
        try {
            bufferedReader.readLine();
            int i2 = -1;
            int i3 = 2;
            int i4 = 1;
            while (true) {
                String line = bufferedReader.readLine();
                if (line == null) {
                    return i2;
                }
                StringTokenizer stringTokenizer = new StringTokenizer(line, StringUtils.SPACE);
                try {
                    int i5 = Integer.parseInt(stringTokenizer.nextToken());
                    if (i5 >= 2 && i5 <= this.dimension) {
                        int i6 = Integer.parseInt(stringTokenizer.nextToken());
                        int i7 = Integer.parseInt(stringTokenizer.nextToken());
                        int[] iArr = new int[i6 + 1];
                        for (int i8 = 1; i8 <= i6; i8++) {
                            iArr[i8] = Integer.parseInt(stringTokenizer.nextToken());
                        }
                        initDirectionVector(i4, i7, iArr);
                        i4++;
                    }
                    if (i5 > this.dimension) {
                        return i5;
                    }
                    i3++;
                    i2 = i5;
                } catch (NumberFormatException unused) {
                    throw new MathParseException(line, i3);
                } catch (NoSuchElementException unused2) {
                    throw new MathParseException(line, i3);
                }
            }
        } finally {
            bufferedReader.close();
        }
    }

    private void initDirectionVector(int i, int i2, int[] iArr) {
        int length = iArr.length;
        int i3 = length - 1;
        for (int i4 = 1; i4 <= i3; i4++) {
            this.direction[i][i4] = iArr[i4] << (52 - i4);
        }
        for (int i5 = length; i5 <= 52; i5++) {
            long[] jArr = this.direction[i];
            long j = jArr[i5 - i3];
            jArr[i5] = j ^ (j >> i3);
            int i6 = 1;
            while (true) {
                if (i6 <= length - 2) {
                    long[] jArr2 = this.direction[i];
                    jArr2[i5] = jArr2[i5] ^ (((i2 >> (r4 - i6)) & 1) * jArr2[i5 - i6]);
                    i6++;
                }
            }
        }
    }

    @Override // org.apache.commons.math3.random.RandomVectorGenerator
    public double[] nextVector() {
        double[] dArr = new double[this.dimension];
        int i = this.count;
        if (i == 0) {
            this.count = i + 1;
            return dArr;
        }
        int i2 = i - 1;
        int i3 = 1;
        while ((i2 & 1) == 1) {
            i2 >>= 1;
            i3++;
        }
        for (int i4 = 0; i4 < this.dimension; i4++) {
            long[] jArr = this.x;
            long j = jArr[i4] ^ this.direction[i4][i3];
            jArr[i4] = j;
            dArr[i4] = j / SCALE;
        }
        this.count++;
        return dArr;
    }

    public double[] skipTo(int i) throws NotPositiveException {
        if (i == 0) {
            Arrays.fill(this.x, 0L);
        } else {
            int i2 = i - 1;
            long j = i2 ^ (i2 >> 1);
            for (int i3 = 0; i3 < this.dimension; i3++) {
                long j2 = 0;
                for (int i4 = 1; i4 <= 52; i4++) {
                    long j3 = j >> (i4 - 1);
                    if (j3 == 0) {
                        break;
                    }
                    j2 ^= (j3 & 1) * this.direction[i3][i4];
                }
                this.x[i3] = j2;
            }
        }
        this.count = i;
        return nextVector();
    }
}
