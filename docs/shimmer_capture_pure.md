# ShimmerCapturePure Integration Notes

## Overview

- ShimmerCapturePure bundles device orchestration, live plotting, logging, and optional Verisense workflows into a
  single Android app. Interaction layers stack as: Activity/Fragments → `ShimmerService` (bound service) →
  `ShimmerBluetoothManagerAndroid` → transport-specific drivers (`ShimmerBluetooth`, Verisense byte comms). Optional
  remote control is exposed through generated gRPC clients and servers.

## Main Activity

- `com/shimmerresearch/shimmercapture/MainActivity.java` drives UI state and encapsulates the service binding. A single
  pager coordinates the connected devices, sensor toggles, configuration and plotting fragments (
  `MainActivity.java:70-180`). Device events from the service are funneled through `mHandler` to update lists, plots and
  toast notifications in response to state changes such as connect, stream and disconnect (`MainActivity.java:104-182`).
- During `onCreate`, the activity primes the runtime permission flow, instantiates the fragments and registers the
  service intent (`MainActivity.java:191-238`). When users choose a device from the Bluetooth dialog, `onActivityResult`
  either requests a preferred radio (BT classic vs BLE) or connects directly through the service (
  `MainActivity.java:584-606`).
- Selecting a device rebuilds the UI: the fragment list is refreshed, streaming is paused, and the fragments receive the
  bound service instance. For BLE devices the polling timer is paused during the reconfiguration, then restarted once
  the view updates (`MainActivity.java:760-799`).
- Sensor configuration writes originate from `SensorsEnabledFragment` but are orchestrated through the activity: once
  the "Write config" footer button is pressed, the activity’s callback rebuilds the device configuration display and
  leaves the service responsible for pushing the generated bytes (`MainActivity.java:805-807`).

## Service Layer

- `com/shimmerresearch/android/shimmerService/ShimmerService.java` is a long-lived bound service that owns the
  `ShimmerBluetoothManagerAndroid` instance (`ShimmerService.java:212-221`). It exposes helper APIs for connecting,
  streaming and querying devices on behalf of the UI, but the heavy lifting happens inside the central `Handler` (
  `ShimmerService.java:45-200`).
- All radio callbacks flow through `handleMsgDataPacket`, which performs three critical jobs: optional algorithm
  pipelines (PPG/ECG HR), the GSR conversion (see below), and delegating to the plotting manager/loggers (
  `ShimmerService.java:328-399`).
- State changes update internal bookkeeping (`mMultiShimmer`, logging maps) and broadcast intents for any interested
  receivers. Each transition sends Bluetooth state, MAC address and friendly name, ensuring fragments and external
  components stay synchronized (`ShimmerService.java:420-480`).
- The service exposes wiring for logging, streaming, and device-level settings—most “Deprecated” wrappers simply
  delegate to the Bluetooth manager (`ShimmerService.java:572-840`), keeping MainActivity agnostic of the transport
  layer.

## Bluetooth Manager

- `com/shimmerresearch/android/manager/ShimmerBluetoothManagerAndroid.java` extends the shared manager and adapts it to
  Android’s Bluetooth stack. Construction validates the adapter and preloads the bonded device map, failing fast if
  Bluetooth is disabled (`ShimmerBluetoothManagerAndroid.java:123-150`).
- The manager supports pairing prompts and dual transport (classic and BLE). When the UI selects a device, it wraps the
  MAC/name into a `BluetoothDeviceDetails`, registers a connection exception listener and drives the underlying
  `ShimmerRadioInitializer` to create `Shimmer` or `Shimmer4Android` instances (
  `ShimmerBluetoothManagerAndroid.java:178-252`, `ShimmerBluetoothManagerAndroid.java:322-358`).
- Configuration is applied asynchronously: `configureShimmer` spawns a worker that ultimately calls `configureShimmers`,
  consuming the clone prepared by `SensorsEnabledFragment` (`ShimmerBluetoothManagerAndroid.java:360-368`).
- Device control helpers iterate the connected map, checking state before issuing commands. GSR range helpers either
  broadcast to all devices or target a specific address while ensuring the radio is connected or logging (
  `ShimmerBluetoothManagerAndroid.java:483-500`, `ShimmerBluetoothManagerAndroid.java:631-689`).

## Sensor Definitions

- `com/shimmerresearch/sensors/SensorGSR.java` defines the Shimmer3 GSR payload: command opcodes, reference resistors,
  min/max limits and display strings for both resistance and conductance ranges (`SensorGSR.java:25-174`). The class
  prepares a sensor map entry so UI code can present “GSR Range” as a standard configuration option and exposes metadata
  for ObjectCluster entries (`SensorGSR.java:175-197`).
- The driver retains the current range in `ShimmerObject`—defaulting to auto-range—providing getters and setters for
  other layers to interrogate (`ShimmerObject.java:457-620`).
- Variant devices (e.g., Verisense) extend the base behavior through classes like `SensorGSRVerisense`, but the core app
  wires the common sensor definition into its clone/configure workflow (
  `com/shimmerresearch/verisense/sensors/SensorGSRVerisense.java` builds on `SensorGSR`).

## Major Features

- **Device discovery & connection:** Combined support for classic Shimmer3, BLE-enabled Shimmer3R, and Verisense
  wearables. Connection logic negotiates pairing requirements, transport type, and version checks before streaming (
  `MainActivity.java:584-595`, `ShimmerBluetoothManagerAndroid.java:178-252`).
- **Sensor configuration & validation:** Deep-clone workflow lets the user toggle sensor groups, applies compatibility
  filtering, then runs configuration generation and conflict correction before writes (
  `SensorsEnabledFragment.java:82-172`, `AssembleShimmerConfig.java:9-81`).
- **Real-time streaming & visualization:** Unified handler pipeline feeds `PlotFragment`, `SignalsToPlotFragment`, and
  optional HR algorithms for ECG/PPG. Packet reception rate, state transitions, and derived signals all originate from
  `ShimmerService` callbacks (`ShimmerService.java:328-399`, `PlotFragment.java:64-319`).
- **Logging and playback:** `ShimmerService` can log streamed `ObjectCluster` data (CSV/DAT) while stripping transient
  telemetry before persistence (`ShimmerService.java:328-399`). Log paths are surfaced to the UI when active.
- **GSR processing:** Resistance-to-conductance conversion, range management, and firmware command helpers reside in
  service/manager layers, ensuring calibrated micro-siemens values and remote control over auto-ranging (
  `ShimmerService.java:357-359`, `ShimmerBluetoothManagerAndroid.java:493-689`, `ShimmerBluetooth.java:2920-2933`).
- **Verisense data sync:** Additional fragment and command set for transferring logged payloads, selecting storage
  destinations, and tracking progress metrics (`MainActivity.java:167-171`, `MainActivity.java:780-793`,
  `DataSyncFragment.java:16-44`).
- **Remote control & integration:** Generated gRPC clients/servers allow desktop tooling or other services to connect,
  control, and collect data from Shimmer devices (see next section).

## Settings & Configuration

- **GUI-driven settings:** `ShimmerDialogConfigurations` exposes runtime dialogs for sensor enablement and per-sensor
  options, cloning the active `ShimmerDevice` before submitting configuration updates (
  `ShimmerDialogConfigurations.java:1-200`, `ShimmerDialogConfigurations.java:120-196`). These dialogs rely on each
  sensor’s `ConfigOptionDetails` to populate combo boxes, ranges, and enumerations.
- **Programmatic profiles:** `Configuration.java` contains the enumerations for sensor IDs, communication types, channel
  units, and compatibility metadata, providing the constants consumed across the UI and driver layers (
  `com/shimmerresearch/driver/Configuration.java:1-400`).
- **Auto-generated configs:** `AssembleShimmerConfig.generateMultipleShimmerConfig` checks for conflicts (e.g., sync
  logging groups, duplicate names), stamps experiment IDs, and prepares byte arrays for Bluetooth or dock writes (
  `AssembleShimmerConfig.java:19-81`). This is the same entry point you can call from Buccancs if you need to modify
  configuration outside the UI.
- **Persisted selections:** While the decompiled APK doesn’t expose SharedPreferences, the `ShimmerService` retains
  runtime decisions—`mLogFolderName`, `mLoggingFileType`, `mConvertGSRtoSiemens`, algorithm enable flags—so Buccancs
  code can toggle them through the binder before or after binding (`ShimmerService.java:65-200`).

## Streaming Pipeline

- **State machine:** `ShimmerService` forwards BT state transitions (`CONNECTING`, `CONNECTED`, `STREAMING`,
  `SDLOGGING`, etc.) through `handleMsgStateChange`, which also updates `mMultiShimmer` and broadcasts intents for
  observers (`ShimmerService.java:403-480`). `MainActivity` consumes the same messages to refresh fragments and toast
  notifications (`MainActivity.java:104-182`).
- **Data packets:** Every `ObjectCluster` entering `handleMsgDataPacket` can be filtered, augmented (GSR conversion, HR
  algorithms), logged, plotted, and forwarded to registered handlers (`ShimmerService.java:328-399`). This is the choke
  point for injecting Buccancs logic or forwarding data to your own pipeline.
- **Plot/Signal sync:** `SignalsToPlotFragment` builds the list of available channels from the streaming device and uses
  `PlotManagerAndroid` to add/remove series, keeping both the ListView and plot in sync with the user’s choices (
  `SignalsToPlotFragment.java:20-119`, `PlotManagerAndroid.java:1-210`).
- **Logging control:** Commands such as `startStreaming`, `stopStreaming`, `startLogAndStreaming`, and GSR range updates
  are all delegated from the service to the Bluetooth manager, ensuring state checks (connected vs SD logging) before
  hitting the radio (`ShimmerService.java:793-809`, `ShimmerBluetoothManagerAndroid.java:483-689`).

## Networking & Remote Interfaces

- **Local BLE/Classic stack:** `ShimmerBluetoothManagerAndroid` handles direct radio connections via Android BLE APIs or
  classic SPP sockets, maintaining maps of bonded, discovered, and connected devices (
  `ShimmerBluetoothManagerAndroid.java:70-420`).
- **gRPC control plane:** `ShimmerServerGrpc` and `ShimmerClientGrpcStream` provide remote procedure calls for
  connect/disconnect/start/stop streaming, retrieving device info, downloading SD data, and bi-directional transfer of
  `ObjectCluster` payloads (`ShimmerServerGrpc.java`, `ShimmerClientGrpcStream.java:17-71`). Buccancs can reuse these
  services to command PURE instances from external processes without embedding Android logic.
- **BLE proxy over gRPC:** `GrpcBLERadioByteTools` + `GrpcBLERadioByteCommunication` enable scenarios where the wearable
  is connected to a desktop host; the Android app communicates with that host over TCP/gRPC, but exposes the same
  byte-communication API to the Verisense protocol (`GrpcBLERadioByteTools.java:1-120`,
  `GrpcBLERadioByteCommunication.java:18-170`).
- **File synchronization:** `VerisenseProtocolByteCommunicationAndroid` streams logged payloads into the Storage Access
  Framework folder selected by the user, using gRPC or native BLE underneath depending on the byte-communication
  implementation (`VerisenseProtocolByteCommunicationAndroid.java:7-97`).

## Control Commands & Firmware Interaction

- **Shimmer3/3R command set:** `ShimmerBluetooth` includes helpers for all major operations—sensor enable masks, range
  writes, calibration, logging toggle, baud rate changes, EXG configuration—with command bytes documented alongside each
  method (`ShimmerBluetooth.java:2880-3200`). Range and configuration opcodes map directly to public APIs (e.g.,
  `writeGSRRange` -> opcode `33`, `readGSRRange` -> opcode `35`).
- **Sensor metadata:** Each sensor class (e.g., `SensorGSR`, `SensorBattVoltage`, `SensorLSM6DSV`, etc.) defines its
  configuration handles, channel names, and calibration constants. Buccancs can inspect these classes to know which
  channel strings or configuration keys to expect at runtime (`com/shimmerresearch/sensors/*`).
- **Verisense protocol:** `VerisenseProtocolByteCommunication` manages message framing, CRC handling, ACK/NAK
  processing, and keeps the latest payloads for base-band config, operational schedules, and status (
  `VerisenseProtocolByteCommunication.java:42-210`). Commands correspond to `VerisenseMessage` property enums, so you
  can hook into `stateChange` or `handleResponse` to react to device events.
- **Configuration map access:** `ShimmerDevice.getConfigOptionsMap()` returns `ConfigOptionDetailsSensor` entries keyed
  by display name, each offering allowed values and mapping to firmware properties. Buccancs can interrogate this map to
  dynamically present configuration options or to apply defaults (`ShimmerDevice.java`,
  `ShimmerDialogConfigurations.java:120-200`).

## Subsystem Reference

- **Signal-picker & plotting pipeline:** `SignalsToPlotFragment` inspects the active device, maps each enabled
  channel/type into `PlotManagerAndroid`, and keeps selections synchronized with the live plot (
  `SignalsToPlotFragment.java:20-119`). `PlotManagerAndroid` extends a reusable plotting framework, managing series life
  cycle, color assignment, and X-axis constraints for all chosen signals (`PlotManagerAndroid.java:1-210`).
- **Sensor library:** Beyond GSR, the `com/shimmerresearch/sensors` package enumerates accelerometer, gyroscope,
  magnetometer, PPG/ECG, temperature, battery, and derived algorithm sensors. Each class mirrors the pattern seen in
  `SensorGSR`—command opcodes, calibration coefficients, `ChannelDetails`, and GUI metadata—meaning all sensors surface
  through the same clone/config/stream pipeline once enabled.
- **Verisense protocol stack:** `VerisenseProtocolByteCommunication` orchestrates low-level message framing, state
  transitions, and command/response handling for Verisense hardware (`VerisenseProtocolByteCommunication.java:42-210`).
  The Android specialization decorates the base class with SAF file support so logged payloads are streamed into
  user-selected directories (`VerisenseProtocolByteCommunicationAndroid.java:7-97`). Radio listeners can subscribe to
  state-change callbacks, while a circular buffer guards in-flight messages.
- **gRPC BLE bridge:** When a wearable is proxied through a desktop BLE adapter, `GrpcBLERadioByteTools` spawns the
  external `.exe`, discovers a free port, and marshals console output (`GrpcBLERadioByteTools.java:1-120`).
  `GrpcBLERadioByteCommunication` implements `AbstractByteCommunication`, exposing the same connect/read/write surface
  expected by the Verisense protocol but tunneling bytes over gRPC streams (
  `GrpcBLERadioByteCommunication.java:18-170`).

## gRPC Integration

- **Control plane (`ShimmerServerGrpc`):** Auto-generated stubs expose operations such as connect/disconnect, start/stop
  streaming, workspace management, SD-card tasks, and observing live `ObjectCluster` streams (
  `com/shimmerresearch/grpc/ShimmerServerGrpc.java`). `ShimmerClientGrpcStream` wraps the async stub to subscribe to
  `ObjectCluster2` payloads and forward them into the driver callback chain (
  `com/shimmerresearch/grpc/ShimmerClientGrpcStream.java:17-71`).
- **Proto definitions:** `ShimmerGRPC.java` contains the compiled protobuf schema, defining messages like
  `ShimmerRequest`, `CommandStatus`, `ObjectCluster2`, and helper container messages used across both client and server
  sides (`com/shimmerresearch/grpc/ShimmerGRPC.java`).
- **BLE bridge (`GrpcBLERadioByteCommunication` & tools):** For environments where the wearable is proxied via a desktop
  BLE adapter, the app can talk to an external executable (`ShimmerBLEGrpc.exe`) through gRPC. `GrpcBLERadioByteTools`
  manages spawning the process and picking a free port, while `GrpcBLERadioByteCommunication` implements the
  `AbstractByteCommunication` contract by opening a gRPC channel, issuing connect/read/write RPCs, and streaming
  `ObjectCluster` bytes back into the Verisense driver stack (`com/shimmerresearch/grpc/GrpcBLERadioByteTools.java`,
  `com/shimmerresearch/grpc/GrpcBLERadioByteCommunication.java:18-170`).
- **Driver serialization:** `ObjectCluster` can be constructed from `ShimmerGRPC.ObjectCluster2`, allowing the same data
  structures to cross process boundaries via gRPC before re-entering the Android service (
  `com/shimmerresearch/driver/ObjectCluster.java:7`, plus constructors mapping protobuf fields).
- **Extensibility:** The presence of both unary (command/response) and streaming RPCs means the mobile app can act as
  either client or server, enabling integration with lab automation, remote diagnostics, or custom dashboards without
  modifying the Android UI.

## Verisense Integration

- Device selection branches early: when a discovered name contains “Verisense”, the service delegates to
  `connectVerisenseDevice`, which spins up `VerisenseProtocolByteCommunicationAndroid` instead of a classic/BLE radio (
  `com/shimmerresearch/android/shimmerService/ShimmerService.java:296-301`,
  `com/shimmerresearch/android/manager/ShimmerBluetoothManagerAndroid.java:215-243`).
- Verisense devices expose additional sync capabilities. On selection the activity keeps the generic fragments in place
  but also enables the data-sync tab, defaulting placeholder participant/trial values and wiring the “Sync” button to
  `ACTION_OPEN_DOCUMENT_TREE` (`com/shimmerresearch/shimmercapture/MainActivity.java:780-793`,
  `com/shimmerresearch/android/guiUtilities/supportfragments/DataSyncFragment.java:16-44`).
- Streaming callbacks still pass through the same handler chain, but Verisense-specific payloads (e.g.,
  `SyncProgressDetails`) arrive on `message.what == 10`, allowing the activity to update transfer speed, payload index
  and destination path while the protocol layer continues reading from the wearable (`MainActivity.java:167-171`).
- The Verisense sensor definition inherits GSR behavior while overriding range defaults and resistor tables (
  `com/shimmerresearch/verisense/sensors/SensorGSRVerisense.java:23-138`), so the rest of the app can treat the device
  like any other with the benefit of hardware-specific constants.

## End-to-End GSR Flow

### UI and Configuration

- When a user selects a device, `MainActivity` instructs the `SensorsEnabledFragment` to rebuild its list from a deep
  clone (`MainActivity.java:760-776`; `SensorsEnabledFragment.java:82-108`). The fragment filters compatible sensor
  groups, mirrors checkbox state into the clone and, on confirmation, generates configuration bytes via
  `AssembleShimmerConfig.generateMultipleShimmerConfig` before delegating to the Bluetooth manager (
  `SensorsEnabledFragment.java:129-159`).
- `AssembleShimmerConfig` standardizes the configuration workflow: it corrects duplicate names, stamps timestamps,
  option flags, and prepares the config byte arrays that the manager eventually writes out (
  `AssembleShimmerConfig.java:9-81`).

### Runtime Streaming

- During streaming, `ShimmerService` inspects every `ObjectCluster`. If GSR data is present and the “convert to Siemens”
  flag is enabled, it calculates micro-siemens using the resistance sample and augments the cluster with calibrated
  conductance (`ShimmerService.java:357-359`). Downstream components now see both resistance and conductance channels.
- The plotting layer hooks directly into the service. When `PlotFragment` binds, it registers `graphHandler` and updates
  `PlotManagerAndroid`, letting the shared handler deliver state transitions and data points (
  `PlotFragment.java:296-303`). Signal lists and plot traces use the enriched ObjectCluster entries, so any derived GSR
  channel appears in the UI.

### Firmware Commands

- GSR range writes originate from either the “set all” helper or a per-device action. Ultimately they end at
  `ShimmerBluetooth.writeGSRRange`, which assembles the `SET_GSR_RANGE` instruction (opcode `33`) and dispatches it over
  the active comms route, respecting firmware version quirks for Shimmer3 devices (`ShimmerBluetooth.java:2920-2933`).
- Range reads follow the same path through opcode `35`, providing parity with the UI if it needs to verify applied
  settings (`ShimmerBluetooth.java:2920-2924`).

### Plotting & Feedback

- Live plots and signal selectors react to BT state changes funneled through the service handler: `PlotFragment` listens
  for CONNECTED/STREAMING transitions to update labels, start PRR timers and repopulate the selectable signal list (
  `PlotFragment.java:64-172`). When streaming stops, `SignalsToPlotFragment` is reset so the user can choose channels
  afresh (`MainActivity.java:778-782`).
- Packet reception rate and other telemetry are fetched from the same service binding, ensuring a cohesive display that
  reflects both hardware configuration changes and streamed sensor data (`PlotFragment.java:305-319`).

## Key Takeaways

- Activities stay lightweight: the UI surfaces operations while delegating device lifecycles to `ShimmerService`,
  allowing reuse of the service without UI context.
- The service centralizes message handling, guaranteeing that logging, plotting, and UI updates all occur off a single
  source of truth.
- Sensor configuration is clone-based—no direct mutation of the live device. This pattern allows validation,
  compatibility filtering, and conflict correction before applying changes much closer to the radio layer.
- GSR handling is layered but linear: UI selection → clone + config generation → Bluetooth manager write → Shimmer
  firmware instruction. Streaming data takes the reverse path, with `ShimmerService` performing the only unit conversion
  before presentation.

## Session Flow Reference

### Classic Shimmer Session

```
User -> MainActivity: Request device connect (dialog result)
MainActivity -> ShimmerService: connectShimmer(address, name, type)
ShimmerService -> ShimmerBluetoothManagerAndroid: connectShimmerThroughBTAddress(...)
ShimmerBluetoothManagerAndroid -> ShimmerBluetooth: Establish radio, read version
ShimmerBluetooth -> ShimmerService.Handler: BT_STATE.CONNECTED message
ShimmerService.Handler -> MainActivity.Handler: propagate state (message.what == 0)
MainActivity -> SensorsEnabledFragment: buildSensorsList(clone)
User -> SensorsEnabledFragment: Toggle sensors + Write config
SensorsEnabledFragment -> ShimmerBluetoothManagerAndroid: configureShimmer(clone)
ShimmerBluetoothManagerAndroid -> ShimmerBluetooth: push configuration bytes
ShimmerBluetooth -> ShimmerService.Handler: BT_STATE.STREAMING + data packets
ShimmerService.Handler: convert GSR, forward to PlotManager/loggers
PlotFragment/SignalsToPlotFragment: render samples, update lists
```

### Verisense Data Sync Session

```
User -> MainActivity: Select Verisense device
MainActivity -> ShimmerService: connectShimmer(address, name, BT_TYPE)
ShimmerService -> ShimmerBluetoothManagerAndroid: connectVerisenseDevice(details)
VerisenseProtocolByteCommunicationAndroid: establish BLE link
MainActivity: enable DataSyncFragment controls
User -> DataSyncFragment: Tap "Sync"
MainActivity -> VerisenseDevice: set trial/participant, open document tree
VerisenseProtocolByteCommunicationAndroid -> ShimmerService.Handler: progress (message.what == 10)
MainActivity.Handler: update payload index, speed, destination path
VerisenseDevice: streams logged payloads until completion
MainActivity.Handler: re-enable inputs, report status
```

## Architecture Map (Conceptual)

- **UI Layer:** `MainActivity` + fragments (ConnectedShimmersList, SensorsEnabled, DeviceConfig, Plot, SignalsToPlot,
  DataSync) coordinate user interactions and delegate work to the bound service.
- **Service Layer:** `ShimmerService` multiplexes Bluetooth callbacks, logging, plotting, and notification broadcasts.
  It keeps shared state (`mMultiShimmer`, `mLogShimmer`, `mPlotManager`) that fragments consume.
- **Bluetooth/Radio Layer:** `ShimmerBluetoothManagerAndroid` abstracts device discovery and connection, instantiating
  driver objects (`Shimmer`, `Shimmer4Android`, `VerisenseDeviceAndroid`). For Verisense, the manager wires in
  `VerisenseProtocolByteCommunicationAndroid`, which in turn depends on an `AbstractByteCommunication` implementation (
  native BLE or gRPC bridge).
- **Driver & Sensor Layer:** `ShimmerBluetooth`, `ShimmerObject`, and the classes in `com/shimmerresearch/sensors`
  define firmware commands, channel mappings, and calibration math. `ObjectCluster` instances carry samples across
  layers, whether local or via gRPC.
- **Integration Layer:** gRPC modules (`ShimmerServerGrpc`, `ShimmerClientGrpcStream`, `GrpcBLERadioByteCommunication`)
  and helper tools interface with external processes or services, allowing remote control, data mirror, or BLE bridging.
