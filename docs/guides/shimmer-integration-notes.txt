SHIMMER INTEGRATION NOTES
=========================

SOURCE LAYOUT
- external/ShimmerAndroidAPI contains the Android UI/service layer, the Shimmer Android Instrument Driver library, and sample apps that exercise the driver.
- external/Shimmer-Java-Android-API hosts the core device drivers, Bluetooth manager base classes, gRPC stubs, and shared utilities that the Android layer relies upon.

ANDROID INSTRUMENT DRIVER (external/ShimmerAndroidAPI/ShimmerAndroidInstrumentDriver)
- Shimmer3BLEAndroid extends ShimmerBluetooth and wraps the BLE transport with FastBle. It negotiates MTU, subscribes to notifications on the Shimmer RX characteristic, feeds bytes into ThreadSafeByteFifoBuffer, and pushes state/data events through Handler callbacks.
- ShimmerBluetoothManagerAndroid derives from the platform-agnostic ShimmerBluetoothManager base class, exposes scanning/pairing helpers via BluetoothLeScanner, and spins up connection threads that instantiate Shimmer3BLEAndroid or other radio implementations based on detected hardware.
- ShimmerService provides a foreground-friendly Android Service that hosts ShimmerBluetoothManagerAndroid, relays Handler messages to any bound clients, manages optional logging/plotting, and handles multi-device coordination including startStreaming/stopStreaming.
- GUI helpers such as ShimmerBluetoothDialog and fragments under guiUtilities provide classic UI flows (device picker, connected device lists) that emit EXTRA_DEVICE_ADDRESS/EXTRA_DEVICE_NAME data for activities.
- The library depends on legacy Android threading primitives (Handler, Thread) and uses ObjectCluster + FormatCluster to deliver calibrated and uncalibrated sensor payloads identified by Configuration.Shimmer3.ObjectClusterSensorName keys.

ANDROID SAMPLE APPS (external/ShimmerAndroidAPI/ShimmerAndroidInstrumentDriver/*Example)
- shimmer3BLEBasicExample shows the minimal loop: initialize BleManager in onCreate, launch ShimmerBluetoothDialog for device selection, instantiate Shimmer3BLEAndroid, and react to MSG_IDENTIFIER_DATA_PACKET by unpacking ObjectCluster contents.
- efficientDataArrayExample extends the basic patterns with burst/buffered reads and channel enablement via Configuration.
- bluetoothManagerExample demonstrates orchestrating multiple devices through ShimmerBluetoothManagerAndroid and visual feedback via Handlers.
- Additional demos (orientation, multiverisense, Verisense) illustrate specialized sensor pipelines that reuse the same Handler message contract and service bindings.

CORE DRIVER STACK (external/Shimmer-Java-Android-API)
- ShimmerBluetoothManager (Java) coordinates connection lifecycles, retry logic, and per-device ShimmerDevice instances. Platform-specific subclasses (Android or desktop) supply concrete radio transports and serial HAL implementations.
- ShimmerDriver encapsulates configuration frames, streaming byte parsing, calibration routines, and maintains ObjectCluster creation. Generated gRPC classes (ShimmerGRPC, ShimmerBLEGRPC, etc.) expose remote control surfaces for off-device orchestration.
- JavaShimmerConnect aggregates a full ShimmerCapture desktop workflow; its code documents higher-level APIs (startStreaming, setSamplingRate, enableSensors) that are equally available on Android via ShimmerDevice.

KEY APIS AND MESSAGE FLOW
- Transport setup: BleManager.getInstance().init(Application) must run before using Shimmer3BLEAndroid. Connections are driven by Shimmer3BLEAndroid.connect(mac, "default") which internally calls BleManager.connect and posts MSG_IDENTIFIER_STATE_CHANGE events.
- Data delivery: Notifications trigger BleNotifyCallback, which funnels bytes through IOThread/ProcessingThread. Parsed packets emerge as ObjectCluster instances on MSG_IDENTIFIER_DATA_PACKET. Each ObjectCluster exposes calibrated ("CAL"), uncalibrated ("RAW"), and unit metadata via FormatCluster.
- Command surface: ShimmerDevice (base class of Shimmer/Verisense variants) exposes APIs such as startStreaming(), stopStreaming(), writeEnabledSensors(), and setSamplingRate(). ShimmerBluetoothManagerAndroid wraps these calls to support multi-device operations, queueing, and auto-start behavior.
- Error and status reporting use Handler messages MSG_IDENTIFIER_STATE_CHANGE, MESSAGE_TOAST, MESSAGE_LOG_AND_STREAM_STATUS_CHANGED, and MSG_IDENTIFIER_NOTIFICATION_MESSAGE. Handlers are registered either directly (activity) or indirectly via ShimmerService, which rebroadcasts to subscribed clients.
- Device selection UI relies on ShimmerBluetoothDialog, which queries paired devices from BluetoothAdapter and returns the user choice to calling activities through startActivityForResult.

CLASS MAP AND RESPONSIBILITIES
- Shimmer3BLEAndroid (androidradiodriver)                 : BLE transport, characteristic discovery, MTU upgrade, IO/processing thread lifecycle, Handler callbacks.
- ShimmerBluetoothManagerAndroid (android.manager)        : Device registry, scan support, pairing workflow, per-device ConnectThread creation, bridge to ShimmerBluetoothManager base logic.
- ShimmerBluetoothManager (core manager)                  : Connection state machine, configuration cloning, streaming orchestration, event marker dispatch, reception rate timers.
- ShimmerService (android.shimmerService)                 : Android Service wrapper that binds UI clients, relays Handler traffic, manages Logging instances, triggers configure/start/stop on the manager.
- ShimmerBluetoothDialog and guiUtilities fragments       : Legacy UI components for device selection and connection state display; serve as reference for expected intents and extras.
- ShimmerDevice (driver)                                  : Core state container for sensor inventory, configuration bytes, sampling rates, calibration, enabled sensors, algorithm modules, and streaming status flags.
- ShimmerBluetooth (driver.bluetooth)                     : Abstract transport layer providing IOThread, ProcessingThread, write queue, ThreadSafeByteFifoBuffer, and message dispatch into ShimmerDevice parsing.
- ObjectCluster / FormatCluster (driver)                  : Typed container for sensor payloads, separating CAL (calibrated), RAW, and ENG units plus metadata such as units, precision, and channel name.
- Configuration (driver) and SensorDetails                : Enumerations and descriptors covering sensor IDs, configuration labels, default ranges, and communication channel layout for each device generation.
- AssembleShimmerConfig / ConfigByteLayout (driverUtilities) : Helpers to build InfoMem layouts, merging sensor enable bits and per-sensor option bytes prior to flashing to the device.
- Logging / PlotManagerAndroid (tools)                    : Optional logging and visualization helpers utilized by ShimmerService when CSV or graphing is enabled.

PIPELINE: CONNECT TO STREAM
1. Scan/Pair         : ShimmerBluetoothManagerAndroid leverages BluetoothAdapter or BluetoothLeScanner to enumerate bonded devices. Selected devices flow through addDiscoveredDevice into the manager maps.
2. Connection Thread : connectShimmerThroughBTAddress spins a ConnectThread that instantiates Shimmer3BLEAndroid with the Handler supplied at manager construction time.
3. BLE Handshake     : Shimmer3BLEAndroid.connect triggers FastBle.connect. On success it sets MTU=251, upgrades PHY when possible, and calls startServiceS to discover the Shimmer service/characteristics before enabling notifications.
4. Thread Startup    : IOThread pulls from ThreadSafeByteFifoBuffer fed by BleNotifyCallback; ProcessingThread optionally handles higher level parsing. initialize() on successful connection bootstraps device state (sensor map, configuration fetch).
5. Message Dispatch  : Parsed bytes become ObjectCluster instances. sendCallBackMsg posts MSG_IDENTIFIER_STATE_CHANGE, MSG_IDENTIFIER_DATA_PACKET, and MESSAGE_TOAST back to the supplied Handler (activity or ShimmerService).
6. Application Layer : Activities, services, or repositories observe the Handler messages, translate ObjectCluster contents into domain objects, and drive UI state. ShimmerService can re-broadcast messages to multiple handlers and optionally log to storage.
7. Command Surface   : Start/stop streaming, sensor enables, and configuration writes route through ShimmerDevice APIs (startStreaming, writeEnabledSensors, setShimmerAndSensorsSamplingRate), which the manager enforces across connected devices.

PIPELINE: CONFIGURATION AND SETTINGS
1. Clone Preparation : UI code or repositories construct a ShimmerDevice clone representing desired settings. ShimmerDevice exposes setSensorEnabledState, setConfigValueUsingConfigLabel, and setShimmerAndSensorsSamplingRate for this purpose.
2. Configuration Bytes: Under the hood ShimmerDevice maintains mConfigBytes (InfoMem image) using ConfigByteLayout and AssembleShimmerConfig. Sensor enables live in the mEnabledSensors bitmask.
3. Applying Settings : ShimmerBluetoothManager.configureShimmers compares clone metadata against connected devices, invokes configureFromClone, and writes the config via ShimmerBluetooth.writeConfigBytes and writeEnabledSensors.
4. Calibration       : When required, setWriteCalibrationDumpWhenConfiguringForClone triggers calibration dumps. ShimmerDevice stores calibration maps (CalibDetails, Sensor-specific calibrations) for use during ObjectCluster construction.
5. Persisted Values  : ShimmerDevice caches InfoMem and user assignment (mTrialName, mShimmerUserAssignedName). The manager can read/restore via getShimmerConfigBytes or request remote InfoMem when reconnected.
6. Fixed Presets     : FixedShimmerConfigs enumerates canned modes (e.g., BASIC_ACCEL, ECG_GSR). ShimmerBluetoothManager can apply these before streaming. Review mFixedShimmerConfigGlobal usage for auto-application.
7. Runtime Adjustments: setEventTriggered/setEventUntrigger propagate event markers to active devices. Additional ConfigOptionDetails enable runtime modifications such as toggling derived sensors or adjusting filter modules.

DATA PROCESSING AND PIPELINING
- ThreadSafeByteFifoBuffer decouples BLE notification bursts from parser throughput, preventing frame loss when Android scheduling is delayed.
- ShimmerBluetooth.IOThread repeatedly calls bytesAvailableToBeRead() (overridden by Shimmer3BLEAndroid to check the buffer) and forwards data into ShimmerDevice.checkAndParseReceivedData().
- ShimmerDevice assembles packets based on sensor IDs defined in Configuration.Shimmer3.ObjectClusterSensorName. It populates ObjectCluster entries with FormatCluster wrappers per available unit variant.
- Algorithms registered via mMapOfAlgorithmModules run after base parsing, adding derived channels (e.g., orientation, HR). To activate algorithm outputs in our app, enable the corresponding modules before streaming.
- Logging (ShimmerService.Logging) consumes ObjectCluster instances to CSV or binary formats, using the same channel metadata. If we rebuild logging, mimic this structure so downstream tools stay compatible.

SETTING FLOW IN ANDROID SERVICE SAMPLE
- ShimmerService.onCreate instantiates ShimmerBluetoothManagerAndroid with its own Handler, ensuring MSG_IDENTIFIER_DATA_PACKET drives both Toasts and plotting/logging.
- bindService clients call getService() -> configure(...) -> startStreaming(...) on individual ShimmerDevice instances retrieved from getHashMapOfShimmersConnected().
- Logging toggles rely on ShimmerService.mEnableLogging and mLogShimmer map. When stopStreaming triggers MESSAGE_STOP_STREAMING_COMPLETE, the service finalizes file handles.
- Settings dialogs in the legacy app use ShimmerDevice getters (getSensorMap, getConfigOptionsMapSensors) to populate UI with available sensors and ranges.

LIBRARIES AND ARTIFACTS
- Third-party Gradle dependencies inside the instrument driver: com.clj.fastble:FastBle:2.4.0 for BLE operations, androidx.appcompat for UI compatibility, androidx.documentfile for storage helpers, com.google.guava:guava:20.0 for collections, and java3d:vecmath for orientation math.
- Bundled JAR/AAR assets (libs/ directory) provide ShimmerBiophysicalProcessingLibrary_Rev_0_11.jar (HR and filtering algorithms), AndroidBluetoothLibrary.jar (legacy classic Bluetooth support), and androidplot-core for charting.
- Our repo mirrors the published artifacts under sdk/libs: shimmerandroidinstrumentdriver-3.2.4_beta.aar (packaged Android layer), shimmerbluetoothmanager-0.11.5_beta.jar and shimmerdriver-0.11.5_beta.jar (core logic), plus shimmerdriverpc for desktop utilities. These match the sources above and are ready for direct Gradle implementation.

APPLICABILITY TO BUCCANCS
- Use shimmerandroidinstrumentdriver-3.2.4_beta.aar together with shimmerdriver and shimmerbluetoothmanager jars to access the same APIs without importing the full external source trees. Ensure the aar/jars are on the buccancs Gradle classpath (implementation(fileTree("sdk/libs")) or explicit coordinates).
- Wrap Shimmer3BLEAndroid and ShimmerBluetoothManagerAndroid inside a Repository that exposes Kotlin Flow/StateFlow outputs. Translate Handler callbacks into coroutine channels to align with our MVVM + Compose architecture.
- Initialize FastBle once in a Hilt-provided Application or Manager class. Inject the repository into ViewModels so Compose UI can render connection state and sensor streams.
- Port the existing permission model: request BLUETOOTH_CONNECT, BLUETOOTH_SCAN, ACCESS_FINE_LOCATION (Android 12 or below) before scanning/connecting.
- Decide between binding to ShimmerService (for background resilience, multi-device, logging) versus instantiating Shimmer3BLEAndroid directly in-process. For foreground-only usage Compose screens can manage the driver without the service; long-lived sessions benefit from adopting the service pattern.
- ObjectCluster is the canonical data container. Define mappers that convert ObjectCluster + FormatCluster values into domain models (e.g., accelerometer triads, GSR metrics) before exposing them through repositories.
- Legacy UI fragments (ShimmerBluetoothDialog, ConnectedShimmersListFragment) can be referenced for workflow logic but should be reimplemented with Compose. They remain useful for understanding expected extras and sequence of operations.
- If gRPC or remote control is required, reuse the generated stubs in external/Shimmer-Java-Android-API/ShimmerDriver/grpcprotosrc, or depend on shimmerdriver-0.11.5_beta.jar which already embeds them.

NEXT STEPS FOR OUR TEAM
- Validate that the sdk/libs artifacts line up with the versions expected by the external sources (FastBle 2.4.0, AndroidX 1.7.x). Update buccancs Gradle configs if mismatched.
- Prototype a Kotlin repository that instantiates Shimmer3BLEAndroid, listens for Handler messages, and emits structured sensor data via Flow to confirm interoperability with Compose screens.
- Review ShimmerService if background capture or multi-sensor logging is required; decide whether to embed similar logic or migrate to WorkManager/foreground service using the same driver APIs.
